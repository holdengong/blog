<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-Hans" lang="zh-Hans">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.67.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>AspNetCore源码解析_1_CORS中间件 &middot; Holden Gong</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://holdengong.com/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://holdengong.com/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://holdengong.com/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://holdengong.com/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://holdengong.com/">
        <h1>Holden Gong</h1>
      </a>
      <p class="lead">
        code & life
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
  
      </ul>
    </nav>
    
    <div>
      
      <p>&copy; 2020. All rights reserved. </p>
      <p>鄂ICP备20003133号</p>
    </div>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>AspNetCore源码解析_1_CORS中间件</h1>
  <time datetime=2020-03-15T17:26:10&#43;0800 class="post-date">Sun, Mar 15, 2020</time>
  <h1 id="概述">概述</h1>
<h2 id="什么是跨域">什么是跨域</h2>
<p>在前后端分离开发方式中，跨域是我们经常会遇到的问题。所谓的跨域，就是处于安全考虑，A域名向B域名发出Ajax请求，浏览器会拒绝，抛出类似下图的错误。</p>
<p><img src="https://fs.31huiyi.com/2c239b54-ad37-4680-bd95-7f76b656be0d.png" alt="image"></p>
<h2 id="jsonp">JSONP</h2>
<p>JSONP不是标准跨域协议，更像是聪明程序员投机取巧的办法。这种方式的原理就是js是没有跨域限制的，你想想你引用bootstrap.js是不是网络地址放进来就可以用了。<br>
<strong>实际上，所有src属性都不限制跨域的，比如img标签使用跨域图片是不会有问题的。</strong></p>
<p>过程大体分下面四步。</p>
<ul>
<li>首先约定数据格式和回调函数名</li>
<li>A网站引用B网站的js</li>
<li>B网站用约定好的回调函数将数据包裹起来，在A引用的js里返回</li>
<li>A网站在回调函数中获取数据</li>
</ul>
<p>这个方案的优点是兼容性比较好，很古老的ie都可以支持，毕竟只是基于js的一个技巧，并没有新的技术或协议。<br>
缺点比较明显，只支持GET，理解起来比较别扭，调用失败不会返回http状态码，安全性存在一定问题。</p>
<h2 id="cors">CORS</h2>
<p>CORS的全称是Cross Origin Resource Sharing，翻译过来就是跨域资源共享。</p>
<p>跨域问题本质就是浏览器处于安全考虑，阻止了客户端跨域请求。但说到底，客户端请求安不安全还不是服务端说了算的，服务端都说我们家大米你们随便吃，浏览器还阻止，这不是碍事吗，你个物业还当自己业主啦？</p>
<p>但是浏览器也不能随便放行，毕竟网上冲浪的不仅有正经客人，还有小偷，真出问题了还得吐槽物业稀烂。浏览器说，服务端，这个客户端要去你家吃大米，你得告诉我你同不同意啊，服务端说我咋告诉你啊，我总不能来个人就冲着岗亭喊 I&rsquo;M OK吧。浏览器说那我们搞个协议吧，整个互联网小区都按这个规范来，你们就按这个格式回复我。</p>
<p>这个协议就是CORS了。</p>
<pre><code class="language-mermaid" data-lang="mermaid">graph LR;
    A(客户端)--&gt;B(不带Orgin跨域请求);
    B--&gt;C(浏览器拒绝);
    A--&gt;D(带Origin跨域请求);
    D--&gt;E(服务端返回白名单);
    E--&gt;F(白名单内);
    E--&gt;G(白名单外);
    F--&gt;H(浏览器放行);
    G--&gt;C
</code></pre><p>CORS的缺点就是IE10以下不支持，如果你的项目需要兼容这些浏览器的话需要注意。</p>
<p>关于CORS协议详细的内容看这篇文章</p>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
</blockquote>
<h2 id="怎么实现cors">怎么实现CORS</h2>
<p>CORS说白了其实就是在响应头里加东西，你可以在运维环节比如nginx加，可以在代码里加，常见的做法是中间件统一处理。AspNetCore为我们提供了CORS中间件。</p>
<h2 id="aspnetcore_cors中间件的使用">AspNetCore_CORS中间件的使用</h2>
<p>使用CORS中间件两句代码就够了,在Startup文件中</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">
<span style="color:#75715e">//注入CORS相关的服务，配置跨域策略 [CorsPolicy]
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> ConfigureServices(IServiceCollection services)
{
    services.AddCors(config=&gt; {
                config.AddPolicy(<span style="color:#e6db74">&#34;CorsPolicy&#34;</span>, policy =&gt; {
                    policy.AllowAnyOrigin().
                        AllowAnyMethod().
                        AllowAnyOrigin().
                        AllowAnyMethod();
                        <span style="color:#75715e">/*注意：AllowAnyOrigin和AllowCredential不能同时出现.否则会报错AllowCredential即是否允许客户端发送cookie，基于安全原因，CORS协议规定不允许AllowOrigin为通配符的情况下设置允许发送cookie
</span><span style="color:#75715e">                        .AllowCredentials();*/</span>
                });
            });
}

<span style="color:#75715e">//使用CORS中间件, 指定使用CorsPolicy
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Configure(IApplicationBuilder app)
{
    app.UseCors(<span style="color:#e6db74">&#34;CorsPolicy&#34;</span>);
}
</code></pre></div><p><strong>注意：AllowAnyOrigin和AllowCredential不能同时配置，否则会报错。如果要允许客户端发送cookie的话，只能使用WithOrgin来执行允许跨域白名单</strong></p>
<p>微软使用的策略设计模式，方便我们灵活使用跨域策略。比如，开发环境允许localhost跨域访问，方便开发调试，正式环境只允许指定域名访问。</p>
<h2 id="源码解析">源码解析</h2>

</div>


    </main>

    
      
    
  </body>
</html>
