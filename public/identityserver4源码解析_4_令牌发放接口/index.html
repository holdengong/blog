<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-Hans" lang="zh-Hans">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.67.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>IdentityServer4源码解析_4_令牌发放接口 &middot; Holden Gong</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://holdengong.com/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://holdengong.com/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://holdengong.com/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://holdengong.com/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://holdengong.com/">
        <h1>Holden Gong</h1>
      </a>
      <p class="lead">
        code & life
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
  
      </ul>
    </nav>
    
    <div>
      <p>&copy; 2020. All rights reserved. </p>
      <p>鄂ICP备20003133号</p>
      <script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1278689390'%3E%3C/span%3E%3Cscript src='https://v1.cnzz.com/z_stat.php%3Fid%3D1278689390%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
    </div>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>IdentityServer4源码解析_4_令牌发放接口</h1>
  <time datetime=2020-03-26T23:49:34&#43;0800 class="post-date">Thu, Mar 26, 2020</time>
  <h1 id="目录">目录</h1>
<ul>
<li><a href="https://holdengong.com/identityserver4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_1_%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84">identityserver4源码解析_1_项目结构</a></li>
<li><a href="https://holdengong.com/identityserver4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_2_%E5%85%83%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3">identityserver4源码解析_2_元数据接口</a></li>
<li><a href="https://holdengong.com/identityserver4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_3_%E8%AE%A4%E8%AF%81%E6%8E%A5%E5%8F%A3">identityserver4源码解析_3_认证接口</a></li>
<li><a href="https://holdengong.com/identityserver4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_4_%E4%BB%A4%E7%89%8C%E5%8F%91%E6%94%BE%E6%8E%A5%E5%8F%A3">identityserver4源码解析_4_令牌发放接口</a></li>
<li><a href="https://holdengong.com/identityserver4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_5_%E6%9F%A5%E8%AF%A2%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%8E%A5%E5%8F%A3">identityserver4源码解析_5_查询用户信息接口</a></li>
<li><a href="https://holdengong.com/identityserver4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_6_%E7%BB%93%E6%9D%9F%E4%BC%9A%E8%AF%9D%E6%8E%A5%E5%8F%A3">identityserver4源码解析_6_结束会话接口</a></li>
<li><a href="https://holdengong.com/identityserver4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_7_%E6%9F%A5%E8%AF%A2%E4%BB%A4%E7%89%8C%E4%BF%A1%E6%81%AF%E6%8E%A5%E5%8F%A3">identityserver4源码解析_7_查询令牌信息接口</a></li>
<li><a href="https://holdengong.com/identityserver4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_8_%E6%92%A4%E9%94%80%E4%BB%A4%E7%89%8C%E6%8E%A5%E5%8F%A3">identityserver4源码解析_8_撤销令牌接口</a></li>
</ul>
<h1 id="协议">协议</h1>
<h2 id="token接口">Token接口</h2>
<p>oidc服务需要提供token接口，提供AccessToken,IdToken,以及RefreshToken（可选）。在授权码模式下，token接口必须使用https。</p>
<h2 id="请求">请求</h2>
<p>必须使用POST方法，使用x-www-form-urlencoded序列化参数，clientId:clientSecret使用Basic加密放在Authorization头中</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#a6e22e">POST</span> /token <span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.1</span>
Host<span style="color:#f92672">:</span> <span style="color:#ae81ff">server.example.com</span>
Content-Type<span style="color:#f92672">:</span> <span style="color:#ae81ff">application/x-www-form-urlencoded</span>
Authorization<span style="color:#f92672">:</span> <span style="color:#ae81ff">Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span>

grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA
&amp;redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
</code></pre></div><h2 id="请求校验">请求校验</h2>
<p>认证服务必须校验下列内容：</p>
<ul>
<li>验证client是否颁发了秘钥</li>
<li>验证为该客户端颁发了授权码</li>
<li>验证授权码有效性</li>
<li>如果可能的话，验证授权码是否被使用过</li>
<li>验证redirect_uri 与发起认证请求时的值一致</li>
</ul>
<h2 id="成功响应">成功响应</h2>
<p>在收到token请求，并校验通过之后，认证服务返回成功报文，报文包含了身份令牌和通行令牌。数据格式使用application/json。token_type必须返回Bearer，其他类型token不在本协议范围内。在OAuth2.0响应报文基础上，oidc增加了id_tken。所有token包含了token或者其他敏感信息的响应报文，必须包含以下响应头。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#960050;background-color:#1e0010">Cache-Control no-store
</span><span style="color:#960050;background-color:#1e0010">Pragma no-cache
</span></code></pre></div><h2 id="失败响应">失败响应</h2>
<p>如果认证失败返回application/json格式错误消息，状态码400</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#960050;background-color:#1e0010">  </span><span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1.1</span> <span style="color:#ae81ff">400</span> <span style="color:#a6e22e">Bad Request</span>
  <span style="color:#ae81ff">Content-Type: application/json</span>
  <span style="color:#ae81ff">Cache-Control: no-store</span>
  <span style="color:#ae81ff">Pragma: no-cache</span>

  {
   &#34;error&#34;: &#34;invalid_request&#34;
  }
</code></pre></div><h2 id="id-token校验">id token校验</h2>
<p>客户端必须校验返回的id token, 校验条件如下。对照这些条件，就可以更懂Microsoft.Authentication.OpenIdConnect里面的代码了，要做的事情很多。</p>
<ol>
<li>如果id token被加密，使用客户端注册时候约定的秘钥和算法解密。如果约定了加密方式，id token未被加密，客户端应该拒绝。</li>
<li>签发方标识必须与iss声明一致</li>
<li>客户端必须校验aud声明包含了它的客户端id，如果id token未返回正确的audience或者反悔了不被新人的audience，应该拒绝</li>
<li>如果id token包含多个audience，需要校验是否有azp声明。azp即Authorized party，标识被授权的client。</li>
<li>如果包含azp声明，客户端需要校验其值是否为自己的客户端id</li>
<li>如果id token由token接口直接颁发给客户端（授权码模式就是如此），客户端必须根据alg参数值的算法验证签名。客户端必须使用签发方提供的秘钥。</li>
<li>alg值默认为RS256，客户端可以在注册的时候使用id_token_signed_response_alg参数指定配置。</li>
<li>如果jwt的alg头使用了基于mac地址的加密算法，如HS256, HS384,HS512，aud声明中的字节会用作验签。（意思是会把mac地址相关信息写在aud声明上？）</li>
<li>The current time MUST be before the time represented by the exp Claim.
当前时间必须早于exp（token过期时间）。</li>
<li>iat（签发时间）可以用于拒绝过早、或者过于频繁签发的token，可以用于预防重放攻击。可接受时间范围由客户端自行决定。</li>
<li>如果认证请求包含了nonce参数，客户端必须交验认证响应中返回的nonce值是否一致。防止重放攻击。</li>
<li>如果客户端请求了acr声明（Authentication Context Class Reference，认证会话上下文，用于表示当前认证会话），必须交验acr值是否合法。</li>
<li>如果客户端请求了auth_time声明，客户端应该校验认证时间是否已经超出，是否需要重新认证。</li>
</ol>
<h2 id="access-token校验">access token校验</h2>
<p>如果id_token中包含了at_hash声明，需要做下面的校验。at_hash标明了access_token和id_token之间的会话关联关系，做这个校验可以防跨站伪造。</p>
<ol>
<li>用idtoken的alg头标明的算法加密access_token，比如alg位RS256，则是用HSA-256算法加密。</li>
<li>取hash值左边一般使用base64url加密</li>
<li>id token中的at_hash值必须跟上个步骤得到的值一致</li>
</ol>
<p>校验规则很多，了解一下即可，绝大部分属于客户端需要做的部分，绝大部分跟安全有关。这一块的实现可以参考Microsoft.Authentication.OpenIdConnect，这是客户端的实现。我们现在看的IdentityServer是认证服务端的实现。</p>
<h1 id="源码">源码</h1>
<h2 id="五种授权模式">五种授权模式</h2>
<p>有下面几种授权模式可以请求token接口</p>
<ul>
<li>授权码模式：最常用的code换token</li>
<li>混合模式：混合模式是授权码模式+简化模式混合使用的方式，在用授权码code找token接口换通行/身份令牌的逻辑与授权码模式的逻辑是一样的。idsv4中，混合模式没有自己的单独实现，只是把授权码+简化模式的代码同时调用。</li>
<li>客户端密钥模式：一般用于完全信任的内部系统，密钥换取access_token，由于没有用户参与，scope包含open_id是非法的</li>
<li>用户名密码模式：一般用于第三方对接、无界面交互场景。即username+password换token/id_token，password不一定是密码，也可以是验证码或其他的什么东西，这个完全取决于开发自己的实现</li>
<li>设备流模式（略）</li>
</ul>
<p><strong>注意：简化模式所有的token都是由认证接口（authorize）一次性返回的，不能使用token接口。</strong></p>
<h2 id="校验请求方法">校验请求方法</h2>
<p>token接口仅允许POST方法，Content-Type必须为application/x-www-form-urlencoded，否则抛出InvalidRequest错误。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">async</span> Task&lt;IEndpointResult&gt; ProcessAsync(HttpContext context)
    {
        _logger.LogTrace(<span style="color:#e6db74">&#34;Processing token request.&#34;</span>);

        <span style="color:#75715e">// validate HTTP
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (!HttpMethods.IsPost(context.Request.Method) || !context.Request.HasFormContentType)
        {
            _logger.LogWarning(<span style="color:#e6db74">&#34;Invalid HTTP request for token endpoint&#34;</span>);
            <span style="color:#66d9ef">return</span> Error(OidcConstants.TokenErrors.InvalidRequest);
        }

        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">await</span> ProcessTokenRequestAsync(context);
    }
</code></pre></div><h2 id="处理流程">处理流程</h2>
<ul>
<li>校验客户端</li>
<li>校验请求参数</li>
<li>创建返回值</li>
<li>返回结果</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">async</span> Task&lt;IEndpointResult&gt; ProcessTokenRequestAsync(HttpContext context)
{
    _logger.LogDebug(<span style="color:#e6db74">&#34;Start token request.&#34;</span>);

    <span style="color:#75715e">// validate client
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> clientResult = <span style="color:#66d9ef">await</span> _clientValidator.ValidateAsync(context);

    <span style="color:#66d9ef">if</span> (clientResult.Client == <span style="color:#66d9ef">null</span>)
    {
        <span style="color:#66d9ef">return</span> Error(OidcConstants.TokenErrors.InvalidClient);
    }

    <span style="color:#75715e">// validate request
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> form = (<span style="color:#66d9ef">await</span> context.Request.ReadFormAsync()).AsNameValueCollection();
    _logger.LogTrace(<span style="color:#e6db74">&#34;Calling into token request validator: {type}&#34;</span>, _requestValidator.GetType().FullName);
    <span style="color:#66d9ef">var</span> requestResult = <span style="color:#66d9ef">await</span> _requestValidator.ValidateRequestAsync(form, clientResult);

    <span style="color:#66d9ef">if</span> (requestResult.IsError)
    {
        <span style="color:#66d9ef">await</span> _events.RaiseAsync(<span style="color:#66d9ef">new</span> TokenIssuedFailureEvent(requestResult));
        <span style="color:#66d9ef">return</span> Error(requestResult.Error, requestResult.ErrorDescription, requestResult.CustomResponse);
    }

    <span style="color:#75715e">// create response
</span><span style="color:#75715e"></span>    _logger.LogTrace(<span style="color:#e6db74">&#34;Calling into token request response generator: {type}&#34;</span>, _responseGenerator.GetType().FullName);
    <span style="color:#66d9ef">var</span> response = <span style="color:#66d9ef">await</span> _responseGenerator.ProcessAsync(requestResult);

    <span style="color:#66d9ef">await</span> _events.RaiseAsync(<span style="color:#66d9ef">new</span> TokenIssuedSuccessEvent(response, requestResult));
    LogTokens(response, requestResult);

    <span style="color:#75715e">// return result
</span><span style="color:#75715e"></span>    _logger.LogDebug(<span style="color:#e6db74">&#34;Token request success.&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> TokenResult(response);
}
</code></pre></div><h2 id="校验客户端">校验客户端</h2>
<ul>
<li>解码客户端秘钥，对应的处理类是BasicAuthenticationSecretParser，客户端id和秘钥用base64url加密方法放在Authorzaition头上。base64url基本是明文的，因为授权码换token是后端进行的，所以安全性没有问题</li>
<li>解码得到客户端id和秘钥之后，跟store对比校验客户端是否存在，秘钥是否一致。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">async</span> Task&lt;ClientSecretValidationResult&gt; ValidateAsync(HttpContext context)
{
    _logger.LogDebug(<span style="color:#e6db74">&#34;Start client validation&#34;</span>);

    <span style="color:#66d9ef">var</span> fail = <span style="color:#66d9ef">new</span> ClientSecretValidationResult
    {
        IsError = <span style="color:#66d9ef">true</span>
    };

    <span style="color:#66d9ef">var</span> parsedSecret = <span style="color:#66d9ef">await</span> _parser.ParseAsync(context);
    <span style="color:#66d9ef">if</span> (parsedSecret == <span style="color:#66d9ef">null</span>)
    {
        <span style="color:#66d9ef">await</span> RaiseFailureEventAsync(<span style="color:#e6db74">&#34;unknown&#34;</span>, <span style="color:#e6db74">&#34;No client id found&#34;</span>);

        _logger.LogError(<span style="color:#e6db74">&#34;No client identifier found&#34;</span>);
        <span style="color:#66d9ef">return</span> fail;
    }

    <span style="color:#75715e">// load client
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> client = <span style="color:#66d9ef">await</span> _clients.FindEnabledClientByIdAsync(parsedSecret.Id);
    <span style="color:#66d9ef">if</span> (client == <span style="color:#66d9ef">null</span>)
    {
        <span style="color:#66d9ef">await</span> RaiseFailureEventAsync(parsedSecret.Id, <span style="color:#e6db74">&#34;Unknown client&#34;</span>);

        _logger.LogError(<span style="color:#e6db74">&#34;No client with id &#39;{clientId}&#39; found. aborting&#34;</span>, parsedSecret.Id);
        <span style="color:#66d9ef">return</span> fail;
    }

    SecretValidationResult secretValidationResult = <span style="color:#66d9ef">null</span>;
    <span style="color:#66d9ef">if</span> (!client.RequireClientSecret || client.IsImplicitOnly())
    {
        _logger.LogDebug(<span style="color:#e6db74">&#34;Public Client - skipping secret validation success&#34;</span>);
    }
    <span style="color:#66d9ef">else</span>
    {
        secretValidationResult = <span style="color:#66d9ef">await</span> _validator.ValidateAsync(parsedSecret, client.ClientSecrets);
        <span style="color:#66d9ef">if</span> (secretValidationResult.Success == <span style="color:#66d9ef">false</span>)
        {
            <span style="color:#66d9ef">await</span> RaiseFailureEventAsync(client.ClientId, <span style="color:#e6db74">&#34;Invalid client secret&#34;</span>);
            _logger.LogError(<span style="color:#e6db74">&#34;Client secret validation failed for client: {clientId}.&#34;</span>, client.ClientId);

            <span style="color:#66d9ef">return</span> fail;
        }
    }

    _logger.LogDebug(<span style="color:#e6db74">&#34;Client validation success&#34;</span>);

    <span style="color:#66d9ef">var</span> success = <span style="color:#66d9ef">new</span> ClientSecretValidationResult
    {
        IsError = <span style="color:#66d9ef">false</span>,
        Client = client,
        Secret = parsedSecret,
        Confirmation = secretValidationResult?.Confirmation
    };

    <span style="color:#66d9ef">await</span> RaiseSuccessEventAsync(client.ClientId, parsedSecret.Type);
    <span style="color:#66d9ef">return</span> success;
}
</code></pre></div><h2 id="校验请求参数">校验请求参数</h2>
<ul>
<li>客户端的PortocalType必须位oidc，否则报错InvalidClient</li>
<li>校验GrantType，必填，长度不能超过100。</li>
<li>GrantType默认支持以下几种类型，还可以自定义GrantType
<ul>
<li>authorization_code：授权码换token</li>
<li>client_credentials：客户端秘钥换token</li>
<li>password：用户名密码换token</li>
<li>refresn_token：刷新令牌换token</li>
<li>urn:ietf:params:oauth:grant-type:device_code：deviceflow，略</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">async</span> Task&lt;TokenRequestValidationResult&gt; ValidateRequestAsync(NameValueCollection parameters, ClientSecretValidationResult clientValidationResult)
{
    _logger.LogDebug(<span style="color:#e6db74">&#34;Start token request validation&#34;</span>);

    _validatedRequest = <span style="color:#66d9ef">new</span> ValidatedTokenRequest
    {
        Raw = parameters ?? <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ArgumentNullException(nameof(parameters)),
        Options = _options
    };

    <span style="color:#66d9ef">if</span> (clientValidationResult == <span style="color:#66d9ef">null</span>) <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ArgumentNullException(nameof(clientValidationResult));

    _validatedRequest.SetClient(clientValidationResult.Client, clientValidationResult.Secret, clientValidationResult.Confirmation);

    <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// check client protocol type
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (_validatedRequest.Client.ProtocolType != IdentityServerConstants.ProtocolTypes.OpenIdConnect)
    {
        LogError(<span style="color:#e6db74">&#34;Invalid protocol type for client&#34;</span>,
            <span style="color:#66d9ef">new</span>
            {
                clientId = _validatedRequest.Client.ClientId,
                expectedProtocolType = IdentityServerConstants.ProtocolTypes.OpenIdConnect,
                actualProtocolType = _validatedRequest.Client.ProtocolType
            });

        <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidClient);
    }

    <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// check grant type
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> grantType = parameters.Get(OidcConstants.TokenRequest.GrantType);
    <span style="color:#66d9ef">if</span> (grantType.IsMissing())
    {
        LogError(<span style="color:#e6db74">&#34;Grant type is missing&#34;</span>);
        <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.UnsupportedGrantType);
    }

    <span style="color:#66d9ef">if</span> (grantType.Length &gt; _options.InputLengthRestrictions.GrantType)
    {
        LogError(<span style="color:#e6db74">&#34;Grant type is too long&#34;</span>);
        <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.UnsupportedGrantType);
    }

    _validatedRequest.GrantType = grantType;

    <span style="color:#66d9ef">switch</span> (grantType)
    {
        <span style="color:#66d9ef">case</span> OidcConstants.GrantTypes.AuthorizationCode:
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">await</span> RunValidationAsync(ValidateAuthorizationCodeRequestAsync, parameters);
        <span style="color:#66d9ef">case</span> OidcConstants.GrantTypes.ClientCredentials:
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">await</span> RunValidationAsync(ValidateClientCredentialsRequestAsync, parameters);
        <span style="color:#66d9ef">case</span> OidcConstants.GrantTypes.Password:
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">await</span> RunValidationAsync(ValidateResourceOwnerCredentialRequestAsync, parameters);
        <span style="color:#66d9ef">case</span> OidcConstants.GrantTypes.RefreshToken:
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">await</span> RunValidationAsync(ValidateRefreshTokenRequestAsync, parameters);
        <span style="color:#66d9ef">case</span> OidcConstants.GrantTypes.DeviceCode:
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">await</span> RunValidationAsync(ValidateDeviceCodeRequestAsync, parameters);
        <span style="color:#66d9ef">default</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">await</span> RunValidationAsync(ValidateExtensionGrantRequestAsync, parameters);
    }
}
</code></pre></div><h3 id="参数校验---授权码模式">参数校验 - 授权码模式</h3>
<ul>
<li>客户端AllowedGrantTypes必须包含authorization_code或者hybrid,否则报错UnauthorizedClient。</li>
<li>code必填，code长度不能超过100</li>
<li>客户端传过来的code只是授权码的id，从store中取出来授权码对象，如果不存在返回错误InvalidGrant</li>
<li>从store中移除授权码，此处实现了code只是用一次</li>
<li>如果授权码超出有效时长，返回错误invalidGrant</li>
<li>校验授权码对象的客户端id与当前客户端是否一致</li>
<li>redirect_uri必填，且必须与授权码对象保存的redirect_uri一致，否则返回错误UnauthorizedClient</li>
<li>如果请求中没有任何scope，返回错误invalidRequest</li>
<li>判断用户是否启用，这个判断是由可插拔服务IProfileService的IsActive方法来实现的，开发可以注入自己的实现。如果用户禁用将返回错误InvalidGrant。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">async</span> Task&lt;TokenRequestValidationResult&gt; ValidateAuthorizationCodeRequestAsync(NameValueCollection parameters)
    {
        _logger.LogDebug(<span style="color:#e6db74">&#34;Start validation of authorization code token request&#34;</span>);

        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// check if client is authorized for grant type
</span><span style="color:#75715e"></span>        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (!_validatedRequest.Client.AllowedGrantTypes.ToList().Contains(GrantType.AuthorizationCode) &amp;&amp;
            !_validatedRequest.Client.AllowedGrantTypes.ToList().Contains(GrantType.Hybrid))
        {
            LogError(<span style="color:#e6db74">&#34;Client not authorized for code flow&#34;</span>);
            <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.UnauthorizedClient);
        }

        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// validate authorization code
</span><span style="color:#75715e"></span>        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">var</span> code = parameters.Get(OidcConstants.TokenRequest.Code);
        <span style="color:#66d9ef">if</span> (code.IsMissing())
        {
            LogError(<span style="color:#e6db74">&#34;Authorization code is missing&#34;</span>);
            <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidGrant);
        }

        <span style="color:#66d9ef">if</span> (code.Length &gt; _options.InputLengthRestrictions.AuthorizationCode)
        {
            LogError(<span style="color:#e6db74">&#34;Authorization code is too long&#34;</span>);
            <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidGrant);
        }

        _validatedRequest.AuthorizationCodeHandle = code;

        <span style="color:#66d9ef">var</span> authZcode = <span style="color:#66d9ef">await</span> _authorizationCodeStore.GetAuthorizationCodeAsync(code);
        <span style="color:#66d9ef">if</span> (authZcode == <span style="color:#66d9ef">null</span>)
        {
            LogError(<span style="color:#e6db74">&#34;Invalid authorization code&#34;</span>, <span style="color:#66d9ef">new</span> { code });
            <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidGrant);
        }

        <span style="color:#66d9ef">await</span> _authorizationCodeStore.RemoveAuthorizationCodeAsync(code);

        <span style="color:#66d9ef">if</span> (authZcode.CreationTime.HasExceeded(authZcode.Lifetime, _clock.UtcNow.UtcDateTime))
        {
            LogError(<span style="color:#e6db74">&#34;Authorization code expired&#34;</span>, <span style="color:#66d9ef">new</span> { code });
            <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidGrant);
        }

        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// populate session id
</span><span style="color:#75715e"></span>        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (authZcode.SessionId.IsPresent())
        {
            _validatedRequest.SessionId = authZcode.SessionId;
        }

        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// validate client binding
</span><span style="color:#75715e"></span>        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (authZcode.ClientId != _validatedRequest.Client.ClientId)
        {
            LogError(<span style="color:#e6db74">&#34;Client is trying to use a code from a different client&#34;</span>, <span style="color:#66d9ef">new</span> { clientId = _validatedRequest.Client.ClientId, codeClient = authZcode.ClientId });
            <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidGrant);
        }

        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// validate code expiration
</span><span style="color:#75715e"></span>        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (authZcode.CreationTime.HasExceeded(_validatedRequest.Client.AuthorizationCodeLifetime, _clock.UtcNow.UtcDateTime))
        {
            LogError(<span style="color:#e6db74">&#34;Authorization code is expired&#34;</span>);
            <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidGrant);
        }

        _validatedRequest.AuthorizationCode = authZcode;
        _validatedRequest.Subject = authZcode.Subject;

        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// validate redirect_uri
</span><span style="color:#75715e"></span>        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">var</span> redirectUri = parameters.Get(OidcConstants.TokenRequest.RedirectUri);
        <span style="color:#66d9ef">if</span> (redirectUri.IsMissing())
        {
            LogError(<span style="color:#e6db74">&#34;Redirect URI is missing&#34;</span>);
            <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.UnauthorizedClient);
        }

        <span style="color:#66d9ef">if</span> (redirectUri.Equals(_validatedRequest.AuthorizationCode.RedirectUri, StringComparison.Ordinal) == <span style="color:#66d9ef">false</span>)
        {
            LogError(<span style="color:#e6db74">&#34;Invalid redirect_uri&#34;</span>, <span style="color:#66d9ef">new</span> { redirectUri, expectedRedirectUri = _validatedRequest.AuthorizationCode.RedirectUri });
            <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.UnauthorizedClient);
        }

        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// validate scopes are present
</span><span style="color:#75715e"></span>        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (_validatedRequest.AuthorizationCode.RequestedScopes == <span style="color:#66d9ef">null</span> ||
            !_validatedRequest.AuthorizationCode.RequestedScopes.Any())
        {
            LogError(<span style="color:#e6db74">&#34;Authorization code has no associated scopes&#34;</span>);
            <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidRequest);
        }

        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// validate PKCE parameters
</span><span style="color:#75715e"></span>        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">var</span> codeVerifier = parameters.Get(OidcConstants.TokenRequest.CodeVerifier);
        <span style="color:#66d9ef">if</span> (_validatedRequest.Client.RequirePkce || _validatedRequest.AuthorizationCode.CodeChallenge.IsPresent())
        {
            _logger.LogDebug(<span style="color:#e6db74">&#34;Client required a proof key for code exchange. Starting PKCE validation&#34;</span>);

            <span style="color:#66d9ef">var</span> proofKeyResult = ValidateAuthorizationCodeWithProofKeyParameters(codeVerifier, _validatedRequest.AuthorizationCode);
            <span style="color:#66d9ef">if</span> (proofKeyResult.IsError)
            {
                <span style="color:#66d9ef">return</span> proofKeyResult;
            }

            _validatedRequest.CodeVerifier = codeVerifier;
        }
        <span style="color:#66d9ef">else</span>
        {
            <span style="color:#66d9ef">if</span> (codeVerifier.IsPresent())
            {
                LogError(<span style="color:#e6db74">&#34;Unexpected code_verifier: {codeVerifier}. This happens when the client is trying to use PKCE, but it is not enabled. Set RequirePkce to true.&#34;</span>, codeVerifier);
                <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidGrant);
            }
        }

        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// make sure user is enabled
</span><span style="color:#75715e"></span>        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">var</span> isActiveCtx = <span style="color:#66d9ef">new</span> IsActiveContext(_validatedRequest.AuthorizationCode.Subject, _validatedRequest.Client, IdentityServerConstants.ProfileIsActiveCallers.AuthorizationCodeValidation);
        <span style="color:#66d9ef">await</span> _profile.IsActiveAsync(isActiveCtx);

        <span style="color:#66d9ef">if</span> (isActiveCtx.IsActive == <span style="color:#66d9ef">false</span>)
        {
            LogError(<span style="color:#e6db74">&#34;User has been disabled&#34;</span>, <span style="color:#66d9ef">new</span> { subjectId = _validatedRequest.AuthorizationCode.Subject.GetSubjectId() });
            <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidGrant);
        }

        _logger.LogDebug(<span style="color:#e6db74">&#34;Validation of authorization code token request success&#34;</span>);

        <span style="color:#66d9ef">return</span> Valid();
    }
</code></pre></div><h3 id="参数校验---客户端秘钥模式">参数校验 - 客户端秘钥模式</h3>
<ul>
<li>校验Client是否允许使用客户端秘钥认证模式</li>
<li>校验客户端是否允许访问请求的授权范围scope</li>
<li>scope中包含openid的话返回错误invlidScope，因为本模式没有涉及用户信息</li>
<li>cope中包含offline_access则返回错误InvalidScope，本模式不允许使用refresh_token</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">async</span> Task&lt;TokenRequestValidationResult&gt; ValidateClientCredentialsRequestAsync(NameValueCollection parameters)
    {
        _logger.LogDebug(<span style="color:#e6db74">&#34;Start client credentials token request validation&#34;</span>);

        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// check if client is authorized for grant type
</span><span style="color:#75715e"></span>        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (!_validatedRequest.Client.AllowedGrantTypes.ToList().Contains(GrantType.ClientCredentials))
        {
            LogError(<span style="color:#e6db74">&#34;Client not authorized for client credentials flow, check the AllowedGrantTypes setting&#34;</span>, <span style="color:#66d9ef">new</span> { clientId = _validatedRequest.Client.ClientId });
            <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.UnauthorizedClient);
        }

        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// check if client is allowed to request scopes
</span><span style="color:#75715e"></span>        <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (!<span style="color:#66d9ef">await</span> ValidateRequestedScopesAsync(parameters, ignoreImplicitIdentityScopes: <span style="color:#66d9ef">true</span>, ignoreImplicitOfflineAccess: <span style="color:#66d9ef">true</span>))
        {
            <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidScope);
        }

        <span style="color:#66d9ef">if</span> (_validatedRequest.ValidatedScopes.ContainsOpenIdScopes)
        {
            LogError(<span style="color:#e6db74">&#34;Client cannot request OpenID scopes in client credentials flow&#34;</span>, <span style="color:#66d9ef">new</span> { clientId = _validatedRequest.Client.ClientId });
            <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidScope);
        }

        <span style="color:#66d9ef">if</span> (_validatedRequest.ValidatedScopes.ContainsOfflineAccessScope)
        {
            LogError(<span style="color:#e6db74">&#34;Client cannot request a refresh token in client credentials flow&#34;</span>, <span style="color:#66d9ef">new</span> { clientId = _validatedRequest.Client.ClientId });
            <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidScope);
        }

        _logger.LogDebug(<span style="color:#e6db74">&#34;{clientId} credentials token request validation success&#34;</span>, _validatedRequest.Client.ClientId);
        <span style="color:#66d9ef">return</span> Valid();
    }
</code></pre></div><h3 id="参数校验---用户名密码模式">参数校验 - 用户名密码模式</h3>
<ul>
<li>校验客户端是否允许使用用户名密码模式，校验失败返回UnauthoriedClient错误</li>
<li>校验客户端是否有权访问所请求的所有scope，校验失败返回InvalidScope错误</li>
<li>从请求中获取username和password参数，未提供username返回InvalidGrant错误，未提供password则设置password位空值</li>
<li>username和password长度不能超过100，否则返回InvalidGrant错误</li>
<li>使用IResourceOwnerPasswordValidator校验username和password，此接口需要开发实现后注入，否则会抛出异常</li>
<li>GrantValidationResult的Subject不能为null，因此开发的IResourceOwnerPasswordValidator实现，校验成功后必须给GrantValidationResult赋值</li>
<li>校验用户是否禁用，根据可插拔服务IProfileService的IsAcrtive方法判断，如果禁用返回IvalidGrant错误。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">async</span> Task&lt;TokenRequestValidationResult&gt; ValidateResourceOwnerCredentialRequestAsync(NameValueCollection parameters)
{
    _logger.LogDebug(<span style="color:#e6db74">&#34;Start resource owner password token request validation&#34;</span>);

    <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// check if client is authorized for grant type
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (!_validatedRequest.Client.AllowedGrantTypes.Contains(GrantType.ResourceOwnerPassword))
    {
        LogError(<span style="color:#e6db74">&#34;Client not authorized for resource owner flow, check the AllowedGrantTypes setting&#34;</span>, <span style="color:#66d9ef">new</span> { client_id = _validatedRequest.Client.ClientId });
        <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.UnauthorizedClient);
    }

    <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// check if client is allowed to request scopes
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (!(<span style="color:#66d9ef">await</span> ValidateRequestedScopesAsync(parameters)))
    {
        <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidScope);
    }

    <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// check resource owner credentials
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> userName = parameters.Get(OidcConstants.TokenRequest.UserName);
    <span style="color:#66d9ef">var</span> password = parameters.Get(OidcConstants.TokenRequest.Password);

    <span style="color:#66d9ef">if</span> (userName.IsMissing())
    {
        LogError(<span style="color:#e6db74">&#34;Username is missing&#34;</span>);
        <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidGrant);
    }

    <span style="color:#66d9ef">if</span> (password.IsMissing())
    {
        password = <span style="color:#e6db74">&#34;&#34;</span>;
    }

    <span style="color:#66d9ef">if</span> (userName.Length &gt; _options.InputLengthRestrictions.UserName ||
        password.Length &gt; _options.InputLengthRestrictions.Password)
    {
        LogError(<span style="color:#e6db74">&#34;Username or password too long&#34;</span>);
        <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidGrant);
    }

    _validatedRequest.UserName = userName;


    <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// authenticate user
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> resourceOwnerContext = <span style="color:#66d9ef">new</span> ResourceOwnerPasswordValidationContext
    {
        UserName = userName,
        Password = password,
        Request = _validatedRequest
    };
    <span style="color:#66d9ef">await</span> _resourceOwnerValidator.ValidateAsync(resourceOwnerContext);

    <span style="color:#66d9ef">if</span> (resourceOwnerContext.Result.IsError)
    {
        <span style="color:#75715e">// protect against bad validator implementations
</span><span style="color:#75715e"></span>        resourceOwnerContext.Result.Error = resourceOwnerContext.Result.Error ?? OidcConstants.TokenErrors.InvalidGrant;

        <span style="color:#66d9ef">if</span> (resourceOwnerContext.Result.Error == OidcConstants.TokenErrors.UnsupportedGrantType)
        {
            LogError(<span style="color:#e6db74">&#34;Resource owner password credential grant type not supported&#34;</span>);
            <span style="color:#66d9ef">await</span> RaiseFailedResourceOwnerAuthenticationEventAsync(userName, <span style="color:#e6db74">&#34;password grant type not supported&#34;</span>, resourceOwnerContext.Request.Client.ClientId);

            <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.UnsupportedGrantType, customResponse: resourceOwnerContext.Result.CustomResponse);
        }

        <span style="color:#66d9ef">var</span> errorDescription = <span style="color:#e6db74">&#34;invalid_username_or_password&#34;</span>;

        <span style="color:#66d9ef">if</span> (resourceOwnerContext.Result.ErrorDescription.IsPresent())
        {
            errorDescription = resourceOwnerContext.Result.ErrorDescription;
        }

        LogInformation(<span style="color:#e6db74">&#34;User authentication failed: &#34;</span>, errorDescription ?? resourceOwnerContext.Result.Error);
        <span style="color:#66d9ef">await</span> RaiseFailedResourceOwnerAuthenticationEventAsync(userName, errorDescription, resourceOwnerContext.Request.Client.ClientId);

        <span style="color:#66d9ef">return</span> Invalid(resourceOwnerContext.Result.Error, errorDescription, resourceOwnerContext.Result.CustomResponse);
    }

    <span style="color:#66d9ef">if</span> (resourceOwnerContext.Result.Subject == <span style="color:#66d9ef">null</span>)
    {
        <span style="color:#66d9ef">var</span> error = <span style="color:#e6db74">&#34;User authentication failed: no principal returned&#34;</span>;
        LogError(error);
        <span style="color:#66d9ef">await</span> RaiseFailedResourceOwnerAuthenticationEventAsync(userName, error, resourceOwnerContext.Request.Client.ClientId);

        <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidGrant);
    }

    <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// make sure user is enabled
</span><span style="color:#75715e"></span>    <span style="color:#75715e">/////////////////////////////////////////////
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> isActiveCtx = <span style="color:#66d9ef">new</span> IsActiveContext(resourceOwnerContext.Result.Subject, _validatedRequest.Client, IdentityServerConstants.ProfileIsActiveCallers.ResourceOwnerValidation);
    <span style="color:#66d9ef">await</span> _profile.IsActiveAsync(isActiveCtx);

    <span style="color:#66d9ef">if</span> (isActiveCtx.IsActive == <span style="color:#66d9ef">false</span>)
    {
        LogError(<span style="color:#e6db74">&#34;User has been disabled&#34;</span>, <span style="color:#66d9ef">new</span> { subjectId = resourceOwnerContext.Result.Subject.GetSubjectId() });
        <span style="color:#66d9ef">await</span> RaiseFailedResourceOwnerAuthenticationEventAsync(userName, <span style="color:#e6db74">&#34;user is inactive&#34;</span>, resourceOwnerContext.Request.Client.ClientId);

        <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidGrant);
    }

    _validatedRequest.UserName = userName;
    _validatedRequest.Subject = resourceOwnerContext.Result.Subject;

    <span style="color:#66d9ef">await</span> RaiseSuccessfulResourceOwnerAuthenticationEventAsync(userName, resourceOwnerContext.Result.Subject.GetSubjectId(), resourceOwnerContext.Request.Client.ClientId);
    _logger.LogDebug(<span style="color:#e6db74">&#34;Resource owner password token request validation success.&#34;</span>);
    <span style="color:#66d9ef">return</span> Valid(resourceOwnerContext.Result.CustomResponse);
}
</code></pre></div><h3 id="参数校验---refreshtoken">参数校验 - RefreshToken</h3>
<p>RefreshToken-刷新令牌。顾名思义，用于刷新通行令牌的凭证。拥有offline_access权限的客户端可以使用刷新令牌。只有授权码、混合流程等由后端参与的授权模式才允许使用刷新令牌。</p>
<ul>
<li>从请求中获取refresh_token参数值，如果为空则返回InvalidRequest错误</li>
<li>如果刷新令牌长度超过100，返回InvalidGrant错误</li>
<li>判断刷新令牌是否存在且有效
<ul>
<li>是否能从store中查询到刷新令牌对象</li>
<li>校验刷新令牌是否过期</li>
<li>校验刷新令牌是否属于当前客户端</li>
<li>校验客户端是否仍然有offline_access权限</li>
<li>校验用户是否被禁用</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">async</span> Task&lt;TokenRequestValidationResult&gt; ValidateRefreshTokenRequestAsync(NameValueCollection parameters)
{
    _logger.LogDebug(<span style="color:#e6db74">&#34;Start validation of refresh token request&#34;</span>);

    <span style="color:#66d9ef">var</span> refreshTokenHandle = parameters.Get(OidcConstants.TokenRequest.RefreshToken);
    <span style="color:#66d9ef">if</span> (refreshTokenHandle.IsMissing())
    {
        LogError(<span style="color:#e6db74">&#34;Refresh token is missing&#34;</span>);
        <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidRequest);
    }

    <span style="color:#66d9ef">if</span> (refreshTokenHandle.Length &gt; _options.InputLengthRestrictions.RefreshToken)
    {
        LogError(<span style="color:#e6db74">&#34;Refresh token too long&#34;</span>);
        <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidGrant);
    }

    <span style="color:#66d9ef">var</span> result = <span style="color:#66d9ef">await</span> _tokenValidator.ValidateRefreshTokenAsync(refreshTokenHandle, _validatedRequest.Client);

    <span style="color:#66d9ef">if</span> (result.IsError)
    {
        LogWarning(<span style="color:#e6db74">&#34;Refresh token validation failed. aborting&#34;</span>);
        <span style="color:#66d9ef">return</span> Invalid(OidcConstants.TokenErrors.InvalidGrant);
    }

    _validatedRequest.RefreshToken = result.RefreshToken;
    _validatedRequest.RefreshTokenHandle = refreshTokenHandle;
    _validatedRequest.Subject = result.RefreshToken.Subject;

    _logger.LogDebug(<span style="color:#e6db74">&#34;Validation of refresh token request success&#34;</span>);
    <span style="color:#66d9ef">return</span> Valid();
}
</code></pre></div><h2 id="生成响应报文---授权码模式">生成响应报文 - 授权码模式</h2>
<ul>
<li>生成accessToken和refreshToken
<ul>
<li>通行令牌由ITokenService接口，默认实现DefaultTokenService的CreateAccessTokenAsync方法生成</li>
<li>如果请求了offline_access才生成refresh_token</li>
<li>如果code是oidc授权码，生成id_token。DefaultTokenService的CreateIdentityTokenAsync方法生成Token对象，CreateSecurityTokenAsync方法将Token对象加密为jwt。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">async</span> Task&lt;TokenResponse&gt; ProcessAuthorizationCodeRequestAsync(TokenRequestValidationResult request)
    {
        Logger.LogTrace(<span style="color:#e6db74">&#34;Creating response for authorization code request&#34;</span>);

        <span style="color:#75715e">//////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// access token
</span><span style="color:#75715e"></span>        <span style="color:#75715e">/////////////////////////
</span><span style="color:#75715e"></span>        (<span style="color:#66d9ef">var</span> accessToken, <span style="color:#66d9ef">var</span> refreshToken) = <span style="color:#66d9ef">await</span> CreateAccessTokenAsync(request.ValidatedRequest);
        <span style="color:#66d9ef">var</span> response = <span style="color:#66d9ef">new</span> TokenResponse
        {
            AccessToken = accessToken,
            AccessTokenLifetime = request.ValidatedRequest.AccessTokenLifetime,
            Custom = request.CustomResponse,
            Scope = request.ValidatedRequest.AuthorizationCode.RequestedScopes.ToSpaceSeparatedString(),
        };

        <span style="color:#75715e">//////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// refresh token
</span><span style="color:#75715e"></span>        <span style="color:#75715e">/////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (refreshToken.IsPresent())
        {
            response.RefreshToken = refreshToken;
        }

        <span style="color:#75715e">//////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// id token
</span><span style="color:#75715e"></span>        <span style="color:#75715e">/////////////////////////
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (request.ValidatedRequest.AuthorizationCode.IsOpenId)
        {
            <span style="color:#75715e">// load the client that belongs to the authorization code
</span><span style="color:#75715e"></span>            Client client = <span style="color:#66d9ef">null</span>;
            <span style="color:#66d9ef">if</span> (request.ValidatedRequest.AuthorizationCode.ClientId != <span style="color:#66d9ef">null</span>)
            {
                client = <span style="color:#66d9ef">await</span> Clients.FindEnabledClientByIdAsync(request.ValidatedRequest.AuthorizationCode.ClientId);
            }
            <span style="color:#66d9ef">if</span> (client == <span style="color:#66d9ef">null</span>)
            {
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InvalidOperationException(<span style="color:#e6db74">&#34;Client does not exist anymore.&#34;</span>);
            }

            <span style="color:#66d9ef">var</span> resources = <span style="color:#66d9ef">await</span> Resources.FindEnabledResourcesByScopeAsync(request.ValidatedRequest.AuthorizationCode.RequestedScopes);

            <span style="color:#66d9ef">var</span> tokenRequest = <span style="color:#66d9ef">new</span> TokenCreationRequest
            {
                Subject = request.ValidatedRequest.AuthorizationCode.Subject,
                Resources = resources,
                Nonce = request.ValidatedRequest.AuthorizationCode.Nonce,
                AccessTokenToHash = response.AccessToken,
                StateHash = request.ValidatedRequest.AuthorizationCode.StateHash,
                ValidatedRequest = request.ValidatedRequest
            };

            <span style="color:#66d9ef">var</span> idToken = <span style="color:#66d9ef">await</span> TokenService.CreateIdentityTokenAsync(tokenRequest);
            <span style="color:#66d9ef">var</span> jwt = <span style="color:#66d9ef">await</span> TokenService.CreateSecurityTokenAsync(idToken);
            response.IdentityToken = jwt;
        }

        <span style="color:#66d9ef">return</span> response;
    }
</code></pre></div><h2 id="生成响应报文---客户端密钥模式">生成响应报文 - 客户端密钥模式</h2>
<ul>
<li>仅生成accessToken</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">virtual</span> Task&lt;TokenResponse&gt; ProcessClientCredentialsRequestAsync(TokenRequestValidationResult request)
{
    Logger.LogTrace(<span style="color:#e6db74">&#34;Creating response for client credentials request&#34;</span>);

    <span style="color:#66d9ef">return</span> ProcessTokenRequestAsync(request);
}

<span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">async</span> Task&lt;TokenResponse&gt; ProcessTokenRequestAsync(TokenRequestValidationResult validationResult)
    {
        (<span style="color:#66d9ef">var</span> accessToken, <span style="color:#66d9ef">var</span> refreshToken) = <span style="color:#66d9ef">await</span> CreateAccessTokenAsync(validationResult.ValidatedRequest);
        <span style="color:#66d9ef">var</span> response = <span style="color:#66d9ef">new</span> TokenResponse
        {
            AccessToken = accessToken,
            AccessTokenLifetime = validationResult.ValidatedRequest.AccessTokenLifetime,
            Custom = validationResult.CustomResponse,
            Scope = validationResult.ValidatedRequest.Scopes.ToSpaceSeparatedString()
        };

        <span style="color:#66d9ef">if</span> (refreshToken.IsPresent())
        {
            response.RefreshToken = refreshToken;
        }

        <span style="color:#66d9ef">return</span> response;
    }
</code></pre></div><h2 id="生成响应报文---用户名密码模式">生成响应报文 - 用户名密码模式</h2>
<ul>
<li>生成accessToken</li>
<li>如果申请了offline_access且有权限，同时返回refresh_token</li>
<li>不会返回id_token，我理解的是授权码等模式是有限授权，需要code换id_token，才能拿到用户id以及其他的基本信息。而密码模式是完全信任授权，账号密码都给你了，还整id_token干嘛，你要啥信息，自己实现IResourceOwnerPasswordValidator，自己去库里取就完事了，还要啥自行车。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">virtual</span> Task&lt;TokenResponse&gt; ProcessPasswordRequestAsync(TokenRequestValidationResult request)
    {
        Logger.LogTrace(<span style="color:#e6db74">&#34;Creating response for password request&#34;</span>);

        <span style="color:#66d9ef">return</span> ProcessTokenRequestAsync(request);
    }
</code></pre></div><h2 id="生成响应报文---刷新令牌">生成响应报文 - 刷新令牌</h2>
<ul>
<li>从请求中取出旧通行令牌</li>
<li>判断客户端配置UpdateAccessTokenClaimsOnRefresh-是否在刷新令牌的时候更新通行令牌的claims，默认false。如果为true，则创建新的token对象，否则使用旧的token，只是刷新token的创建时间和有效时间。</li>
<li>判断客户端配置RefreshTokenUsage - 刷新令牌用法，0：ReUse可重复使用 1：OnTimeOnly一次性，默认1。如果是一次性的话，从store中删除旧的刷新令牌，创建新的刷新令牌。</li>
<li>判断客户端配置RefreshTokenExpiration - 刷新令牌过期类型，0：Sliding，1：Absolute，默认1。如果是0，需要重新计算相对时间。</li>
<li>如果刷新令牌请求包含了任意身份资源，创建新的身份令牌。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">async</span> Task&lt;TokenResponse&gt; ProcessRefreshTokenRequestAsync(TokenRequestValidationResult request)
    {
        Logger.LogTrace(<span style="color:#e6db74">&#34;Creating response for refresh token request&#34;</span>);

        <span style="color:#66d9ef">var</span> oldAccessToken = request.ValidatedRequest.RefreshToken.AccessToken;
        <span style="color:#66d9ef">string</span> accessTokenString;

        <span style="color:#66d9ef">if</span> (request.ValidatedRequest.Client.UpdateAccessTokenClaimsOnRefresh)
        {
            <span style="color:#66d9ef">var</span> subject = request.ValidatedRequest.RefreshToken.Subject;

            <span style="color:#66d9ef">var</span> creationRequest = <span style="color:#66d9ef">new</span> TokenCreationRequest
            {
                Subject = subject,
                ValidatedRequest = request.ValidatedRequest,
                Resources = <span style="color:#66d9ef">await</span> Resources.FindEnabledResourcesByScopeAsync(oldAccessToken.Scopes)
            };

            <span style="color:#66d9ef">var</span> newAccessToken = <span style="color:#66d9ef">await</span> TokenService.CreateAccessTokenAsync(creationRequest);
            accessTokenString = <span style="color:#66d9ef">await</span> TokenService.CreateSecurityTokenAsync(newAccessToken);
        }
        <span style="color:#66d9ef">else</span>
        {
            oldAccessToken.CreationTime = Clock.UtcNow.UtcDateTime;
            oldAccessToken.Lifetime = request.ValidatedRequest.AccessTokenLifetime;

            accessTokenString = <span style="color:#66d9ef">await</span> TokenService.CreateSecurityTokenAsync(oldAccessToken);
        }

        <span style="color:#66d9ef">var</span> handle = <span style="color:#66d9ef">await</span> RefreshTokenService.UpdateRefreshTokenAsync(request.ValidatedRequest.RefreshTokenHandle, request.ValidatedRequest.RefreshToken, request.ValidatedRequest.Client);

        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> TokenResponse
        {
            IdentityToken = <span style="color:#66d9ef">await</span> CreateIdTokenFromRefreshTokenRequestAsync(request.ValidatedRequest, accessTokenString),
            AccessToken = accessTokenString,
            AccessTokenLifetime = request.ValidatedRequest.AccessTokenLifetime,
            RefreshToken = handle,
            Custom = request.CustomResponse,
            Scope = request.ValidatedRequest.RefreshToken.Scopes.ToSpaceSeparatedString()
        };
    }
</code></pre></div>
</div>


    </main>

    
      
    
  </body>
</html>
