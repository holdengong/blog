<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-Hans" lang="zh-Hans">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.67.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Holden Gong</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://holdengong.com/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://holdengong.com/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://holdengong.com/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://holdengong.com/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="https://holdengong.com/index.xml" rel="alternate" type="application/rss+xml" title="Holden Gong" />
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://holdengong.com/">
        <h1>Holden Gong</h1>
      </a>
      <p class="lead">
        code & life
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
  
      </ul>
    </nav>
    
    <div>
      <p>&copy; 2020. All rights reserved. </p>
      <p>鄂ICP备20003133号</p>
      <script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1278689390'%3E%3C/span%3E%3Cscript src='https://v1.cnzz.com/z_stat.php%3Fid%3D1278689390%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
    </div>
  </div>
</aside>

    <main class="content container">
    <div class="posts">
<article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/chrome80%E8%B0%83%E6%95%B4samesite%E7%AD%96%E7%95%A5%E5%AF%B9identityserver4%E7%9A%84%E5%BD%B1%E5%93%8D%E4%BB%A5%E5%8F%8A%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/">Chrome80调整SameSite策略对IdentityServer4的影响以及处理方案（翻译）</a>
  </h1>
  <time datetime="2020-03-28T23:43:19&#43;0800" class="post-date">Sat, Mar 28, 2020</time>
  首先，好消息是Goole将于2020年2月份发布Chrome 80版本。本次发布将推行Google的“渐进改良Cookie”策略，努力打造一个更为安全和保障用户隐私的网络环境。
坏消息是，本次更新可能使浏览器无法向服务端发送Cookies。首先，如果你有多个应用，它们各自拥有不同的域名，部分用户很有可能出现会话时常被打断的情况。其次，部分用户可能无法正常登出系统。
本篇博客将处理第一个问题（无法发送cookie到服务端）。至于第二个问题（cookie无法被删除），请参考另一篇博客。
首先，SameSite是什么 互联网是十分开放的平台：Cookie诞生于二十多年前，于2011年修订(RFC 6265)。当时跨站访问攻击（CSRF）没有如此猖獗，侵犯用户隐私的行为也不像现在这样泛滥。
简而言之，Cookie标准规范约定，如果某域名下设置了Cookie，不管你是直接跳转到该域名，或是加载了该域名的某些资源（例如图片），或是向该域名发送POST请求，亦或将其嵌入iframe，浏览器访问该域名的每次请求，都将带上这个Cookie。
对于iframe嵌入这种场景，你可能不希望浏览器将用户会话cookie自动发送到服务端，因为这样任何其他网站都可以在用户不知情的情况下，用他的会话上下文，跟你的服务端发送请求。
为了避免这种情况，SameSite cookie规范于2016年起草。对于发送cookie我们有了更多的控制权：现在可以明确指定每个cookie是否被发送。规范引入了同站/跨站cookie的概念，如果浏览器访问A域名，请求服务端也是A域名，这些cookie就叫同站cookies（same-site cookies），如果浏览器访问A域名，请求服务端是B域名，这些cookie就叫跨站cookies（cross-site cookies）。
为了向后兼容，same-site的默认设置并未改变之前的行为。你必须手动指定SameSite=Lax或者SameSite=Strict，来能使用这项特性加固安全。所有的.NET框架和常见的浏览器都已支持这一特性。设置为Lax，大多数情况不允许发送第三方Cookie，导航到目标网址的Get请求除外。设置为Strict，完全禁止第三方Cookie，除非你之前访问过该域名而Cookie已经存在于浏览器。
悲哀的是，这项新特性的采用率低的可怜（基于Chrome2019年3月份统计显示，在所有的cookie中，只有0.1%使用了SameSite标志）。
Google决定推进这项特性的使用。他们决定修改世界上最多人使用的浏览器——Chrome的默认设置：如果想保持之前处理cookie的方式，Chrome 80要求显示指定SameSite=None。如果像以前一样忽略SameSite属性，Chrome将视作SameSite=Lax。
请注意：SameSite=None只有在Cookie同时被标记为Secure并且使用https连接时才会生效。
Update: If you want more background information about SameSite cookies, there is a new article with all the nitty gritty details.
更新：如果你想知道关于SameSite cookies的更多背景知识，请扩展阅读这篇文章。
这会影响我吗？什么影响？ If you have a single-page web application (SPA) that authenticates against an Identity Provider (IdP, for example IdentityServer 4) that is hosted on a different domain, and that application uses the so-called silent token refresh, you are affected.
  
  
  <div class="read-more-link">
    <a href="/chrome80%E8%B0%83%E6%95%B4samesite%E7%AD%96%E7%95%A5%E5%AF%B9identityserver4%E7%9A%84%E5%BD%B1%E5%93%8D%E4%BB%A5%E5%8F%8A%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/identityserver4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_8_%E6%92%A4%E9%94%80%E4%BB%A4%E7%89%8C%E6%8E%A5%E5%8F%A3/">IdentityServer4源码解析_8_撤销令牌接口</a>
  </h1>
  <time datetime="2020-03-26T23:50:03&#43;0800" class="post-date">Thu, Mar 26, 2020</time>
  目录  identityserver4源码解析_1_项目结构 identityserver4源码解析_2_元数据接口 identityserver4源码解析_3_认证接口 identityserver4源码解析_4_令牌发放接口 identityserver4源码解析_5_查询用户信息接口 identityserver4源码解析_6_结束会话接口 identityserver4源码解析_7_查询令牌信息接口 identityserver4源码解析_8_撤销令牌接口  TO BE UPDATED 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/identityserver4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_7_%E6%9F%A5%E8%AF%A2%E4%BB%A4%E7%89%8C%E4%BF%A1%E6%81%AF%E6%8E%A5%E5%8F%A3/">IdentityServer4源码解析_7_查询令牌信息接口</a>
  </h1>
  <time datetime="2020-03-26T23:49:53&#43;0800" class="post-date">Thu, Mar 26, 2020</time>
  目录  identityserver4源码解析_1_项目结构 identityserver4源码解析_2_元数据接口 identityserver4源码解析_3_认证接口 identityserver4源码解析_4_令牌发放接口 identityserver4源码解析_5_查询用户信息接口 identityserver4源码解析_6_结束会话接口 identityserver4源码解析_7_查询令牌信息接口 identityserver4源码解析_8_撤销令牌接口  TO BE UPDATED 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/identityserver4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_6_%E7%BB%93%E6%9D%9F%E4%BC%9A%E8%AF%9D%E6%8E%A5%E5%8F%A3/">IdentityServer4源码解析_6_结束会话接口</a>
  </h1>
  <time datetime="2020-03-26T23:49:47&#43;0800" class="post-date">Thu, Mar 26, 2020</time>
  目录  identityserver4源码解析_1_项目结构 identityserver4源码解析_2_元数据接口 identityserver4源码解析_3_认证接口 identityserver4源码解析_4_令牌发放接口 identityserver4源码解析_5_查询用户信息接口 identityserver4源码解析_6_结束会话接口 identityserver4源码解析_7_查询令牌信息接口 identityserver4源码解析_8_撤销令牌接口  TO BE UPDATED 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/identityserver4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_5_%E6%9F%A5%E8%AF%A2%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E6%8E%A5%E5%8F%A3/">IdentityServer4源码解析_5_查询用户信息接口</a>
  </h1>
  <time datetime="2020-03-26T23:49:40&#43;0800" class="post-date">Thu, Mar 26, 2020</time>
  目录  identityserver4源码解析_1_项目结构 identityserver4源码解析_2_元数据接口 identityserver4源码解析_3_认证接口 identityserver4源码解析_4_令牌发放接口 identityserver4源码解析_5_查询用户信息接口 identityserver4源码解析_6_结束会话接口 identityserver4源码解析_7_查询令牌信息接口 identityserver4源码解析_8_撤销令牌接口  TO BE UPDATED 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/identityserver4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_4_%E4%BB%A4%E7%89%8C%E5%8F%91%E6%94%BE%E6%8E%A5%E5%8F%A3/">IdentityServer4源码解析_4_令牌发放接口</a>
  </h1>
  <time datetime="2020-03-26T23:49:34&#43;0800" class="post-date">Thu, Mar 26, 2020</time>
  目录  identityserver4源码解析_1_项目结构 identityserver4源码解析_2_元数据接口 identityserver4源码解析_3_认证接口 identityserver4源码解析_4_令牌发放接口 identityserver4源码解析_5_查询用户信息接口 identityserver4源码解析_6_结束会话接口 identityserver4源码解析_7_查询令牌信息接口 identityserver4源码解析_8_撤销令牌接口  协议 Token接口 oidc服务需要提供token接口，提供AccessToken,IdToken,以及RefreshToken（可选）。在授权码模式下，token接口必须使用https。
请求 必须使用POST方法，使用x-www-form-urlencoded序列化参数，clientId:clientSecret使用Basic加密放在Authorization头中
POST /token HTTP/1.1 Host: server.example.com Content-Type: application/x-www-form-urlencoded Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA &amp;redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb 请求校验 认证服务必须校验下列内容：
 验证client是否颁发了秘钥 验证为该客户端颁发了授权码 验证授权码有效性 如果可能的话，验证授权码是否被使用过 验证redirect_uri 与发起认证请求时的值一致  成功响应 在收到token请求，并校验通过之后，认证服务返回成功报文，报文包含了身份令牌和通行令牌。数据格式使用application/json。token_type必须返回Bearer，其他类型token不在本协议范围内。在OAuth2.0响应报文基础上，oidc增加了id_tken。所有token包含了token或者其他敏感信息的响应报文，必须包含以下响应头。
Cache-Control no-store Pragma no-cache 失败响应 如果认证失败返回application/json格式错误消息，状态码400
HTTP/1.1 400 Bad Request Content-Type: application/json Cache-Control: no-store Pragma: no-cache { &#34;error&#34;: &#34;invalid_request&#34; } id token校验 客户端必须校验返回的id token, 校验条件如下。对照这些条件，就可以更懂Microsoft.Authentication.OpenIdConnect里面的代码了，要做的事情很多。
 如果id token被加密，使用客户端注册时候约定的秘钥和算法解密。如果约定了加密方式，id token未被加密，客户端应该拒绝。 签发方标识必须与iss声明一致 客户端必须校验aud声明包含了它的客户端id，如果id token未返回正确的audience或者反悔了不被新人的audience，应该拒绝 如果id token包含多个audience，需要校验是否有azp声明。azp即Authorized party，标识被授权的client。 如果包含azp声明，客户端需要校验其值是否为自己的客户端id 如果id token由token接口直接颁发给客户端（授权码模式就是如此），客户端必须根据alg参数值的算法验证签名。客户端必须使用签发方提供的秘钥。 alg值默认为RS256，客户端可以在注册的时候使用id_token_signed_response_alg参数指定配置。 如果jwt的alg头使用了基于mac地址的加密算法，如HS256, HS384,HS512，aud声明中的字节会用作验签。（意思是会把mac地址相关信息写在aud声明上？） The current time MUST be before the time represented by the exp Claim.
  
  
  <div class="read-more-link">
    <a href="/identityserver4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_4_%E4%BB%A4%E7%89%8C%E5%8F%91%E6%94%BE%E6%8E%A5%E5%8F%A3/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/identityserver4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_3_%E8%AE%A4%E8%AF%81%E6%8E%A5%E5%8F%A3/">IdentityServer4源码解析_3_认证接口</a>
  </h1>
  <time datetime="2020-03-26T23:49:28&#43;0800" class="post-date">Thu, Mar 26, 2020</time>
  目录  identityserver4源码解析_1_项目结构 identityserver4源码解析_2_元数据接口 identityserver4源码解析_3_认证接口 identityserver4源码解析_4_令牌发放接口 identityserver4源码解析_5_查询用户信息接口 identityserver4源码解析_6_结束会话接口 identityserver4源码解析_7_查询令牌信息接口 identityserver4源码解析_8_撤销令牌接口  协议 五种认证方式   Authorization Code 授权码模式：认证服务返回授权码，后端用clientid和密钥向认证服务证明身份，使用授权码换取id token 和/或 access token。本模式的好处是由后端请求token，不会将敏感信息暴露在浏览器。本模式允许使用refreshToken去维持长时间的登录状态。使用此模式的客户端必须有后端参与，能够保障客户端密钥的安全性。此模式从authorization接口获取授权码，从token接口获取令牌。
  Implict 简化模式：校验跳转URI验证客户端身份之后，直接发放token。通常用于纯客户端应用，如单页应用javascript客户端。因为没有后端参与，密钥存放在前端是不安全的。由于安全校验较宽松，本模式不允许使用refreshToken来长时间维持登录状态。本模式的所有token从authorization接口获取。
  Hybrid 混合流程：混合流程顾名思义组合使用了授权码模式+简化模式。前端请求授权服务器返回授权码+id_token，这样前端立刻可以使用用户的基本信息；后续请求后端使用授权码+客户端密钥获取access_token。本模式能够使用refreshToken来长时间维持登录状态。使用本模式必须有后端参与保证客户端密钥的安全性。混合模式极少使用，除非你的确需要使用它的某些特性（如一次请求获取授权码和用户资料），一般最常见的还是授权码模式。
  Resource Owner Password Credential 用户名密码模式：一般用于无用户交互场景，或者第三方对接（如对接微信登录，实际登录界面就变成了微信的界面，如果不希望让客户扫了微信之后再跑你们系统登录一遍，就可以在后端用此模式静默登录接上自家的sso即可）
  Client Credential 客户端密钥模式：仅需要约定密钥，仅用于完全信任的内部系统
  认证方式特点对比    特点 授权码模式 简化模式 混合模式     所有token从Authorization接口返回 No Yes Yes   所有token从Token接口返回 Yes No No   所有tokens不暴露在浏览器 Yes No No   能够验证客户端密钥 Yes No Yes   能够使用刷新令牌 Yes No Yes   仅需一次请求 No Yes No   大部分请求由后端进行 Yes No 可变    支持返回类型对比    返回类型 认证模式 说明     code Authorization Code Flow 仅返回授权码   id_token Implicit Flow 返回身份令牌   id_token token Implicit Flow 返回身份令牌、通行令牌   code id_token Hybrid Flow 返回授权码、身份令牌   code token Hybrid Flow 返回授权码、通行令牌   code id_token token Hybrid Flow 返回授权码、身份令牌、通行令牌    授权码模式解析 相对来说，授权码模式还是用的最多的，我们详细解读一下本模式的协议内容。
  
  
  <div class="read-more-link">
    <a href="/identityserver4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_3_%E8%AE%A4%E8%AF%81%E6%8E%A5%E5%8F%A3/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/identityserver4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_2_%E5%85%83%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3/">IdentityServer4源码解析_2_元数据接口</a>
  </h1>
  <time datetime="2020-03-26T23:49:07&#43;0800" class="post-date">Thu, Mar 26, 2020</time>
  目录  identityserver4源码解析_1_项目结构 identityserver4源码解析_2_元数据接口 identityserver4源码解析_3_认证接口 identityserver4源码解析_4_令牌发放接口 identityserver4源码解析_5_查询用户信息接口 identityserver4源码解析_6_结束会话接口 identityserver4源码解析_7_查询令牌信息接口 identityserver4源码解析_8_撤销令牌接口  协议 这一系列我们都采用这样的方式，先大概看下协议，也就是需求描述，然后看idsv4怎么实现的，这样可以加深理解。
元数据接口的协议地址如下：
 https://openid.net/specs/openid-connect-discovery-1_0.html
 摘要 该协议定义了一套标准，用户能够获取到oidc服务的基本信息，包括OAuth2.0相关接口地址。
Webfinger - 网络指纹 先了解一下Webfinger这个概念。
WebFinger可以翻译成网络指纹，它定义了一套标准，描述如何通过标准的HTTP方法去获取网络实体的资料信息。WebFinger使用JSON来描述实体信息。
 https://tools.ietf.org/html/rfc7033
 查询oidc服务元数据 - OpenID Provider Issuer Discovery 可选协议。
定义了如何获取oidc服务元数据。如果客户端明确知道oidc服务的地址，可以跳过此部分。
个人理解是存在多个oidc服务的情况，可以部署一个webfinger服务，根据资源请求，路由到不同的oidc服务。
通常来说，我们只有一个oidc服务，我看了一下idsv4也没有实现这一部分协议，这里了解一下就可以了。
查询oidc服务配置信息 - OpenID Provider Configuration Request 必选协议。
用于描述oidc服务各接口地址及其他配置信息。
 GET /.well-known/openid-configuration HTTP/1.1 Host: example.com 必须校验issuer与请求地址是否一致
启个idsrv服务调用试一下，返回结果如图 详细信息如下。
{ &#34;issuer&#34;: &#34;https://localhost:10000&#34;, //颁发者地址 &#34;jwks_uri&#34;: &#34;https://localhost:10000/.well-known/openid-configuration/jwks&#34;, //jwks接口地址，查询密钥 &#34;authorization_endpoint&#34;: &#34;https://localhost:10000/connect/authorize&#34;, //认证接口地址 &#34;token_endpoint&#34;: &#34;https://localhost:10000/connect/token&#34;, //令牌发放接口 &#34;userinfo_endpoint&#34;: &#34;https://localhost:10000/connect/userinfo&#34;, //查询用户信息接口 &#34;end_session_endpoint&#34;: &#34;https://localhost:10000/connect/endsession&#34;, //结束会话接口 &#34;check_session_iframe&#34;: &#34;https://localhost:10000/connect/checksession&#34;, //检查会话接口 &#34;revocation_endpoint&#34;: &#34;https://localhost:10000/connect/revocation&#34;, //撤销令牌接口 &#34;introspection_endpoint&#34;: &#34;https://localhost:10000/connect/introspect&#34;, //查询令牌详情接口 &#34;device_authorization_endpoint&#34;: &#34;https://localhost:10000/connect/deviceauthorization&#34;, //设备认证接口 &#34;frontchannel_logout_supported&#34;: true, //是否支持前端登出 &#34;frontchannel_logout_session_supported&#34;: true, //是否支持前端结束会话 &#34;backchannel_logout_supported&#34;: true, //是否支持后端登出 &#34;backchannel_logout_session_supported&#34;: true, //是否支持后端结束会话 &#34;scopes_supported&#34;: [ //支持的授权范围,scope &#34;openid&#34;, &#34;profile&#34;, &#34;userid&#34;, &#34;username&#34;, &#34;email&#34;, &#34;mobile&#34;, &#34;api&#34;, &#34;offline_access&#34; //token过期可用refresh_token刷新换取新token ], &#34;claims_supported&#34;: [ //支持的声明 &#34;sub&#34;, &#34;updated_at&#34;, &#34;locale&#34;, &#34;zoneinfo&#34;, &#34;birthdate&#34;, &#34;gender&#34;, &#34;preferred_username&#34;, &#34;picture&#34;, &#34;profile&#34;, &#34;nickname&#34;, &#34;middle_name&#34;, &#34;given_name&#34;, &#34;family_name&#34;, &#34;website&#34;, &#34;name&#34;, &#34;userid&#34;, &#34;username&#34;, &#34;email&#34;, &#34;mobile&#34; ], &#34;grant_types_supported&#34;: [ //支持的认证类型 &#34;authorization_code&#34;, //授权码模式 &#34;client_credentials&#34;, //客户端密钥模式 &#34;refresh_token&#34;, //刷新token &#34;implicit&#34;, //隐式流程, 一般用于单页应用javascript客户端 &#34;password&#34;, //用户名密码模式 &#34;urn:ietf:params:oauth:grant-type:device_code&#34; //设备授权码 ], &#34;response_types_supported&#34;: [ //支持的返回类型 &#34;code&#34;, //授权码 &#34;token&#34;, //通行令牌 &#34;id_token&#34;, //身份令牌 &#34;id_token token&#34;, //身份令牌+统通行令牌 &#34;code id_token&#34;, //授权码+身份令牌 &#34;code token&#34;, //授权码+通行令牌 &#34;code id_token token&#34; //授权码+身份令牌+通行令牌 ], &#34;response_modes_supported&#34;: [ //支持的响应方法 &#34;form_post&#34;, //form-post提交 &#34;query&#34;, //get提交 &#34;fragment&#34; //fragment提交 ], &#34;token_endpoint_auth_methods_supported&#34;: [ //发放令牌接口支持的认证方式 &#34;client_secret_basic&#34;, //basic &#34;client_secret_post&#34; //post ], &#34;id_token_signing_alg_values_supported&#34;: [ //身份令牌加密算法 &#34;RS256&#34; ], &#34;subject_types_supported&#34;: [ &#34;public&#34; ], &#34;code_challenge_methods_supported&#34;: [ &#34;plain&#34;, &#34;S256&#34; ], &#34;request_parameter_supported&#34;: true } JWK - Json Web Keys idsv还注入这样一个接口：DiscoveryKeyEndpoint，尝试发现返回了一组密钥。协议内容如下。
  
  
  <div class="read-more-link">
    <a href="/identityserver4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_2_%E5%85%83%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/identityserver4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_1_%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/">IdentityServer4源码解析_1_项目结构</a>
  </h1>
  <time datetime="2020-03-26T20:31:25&#43;0800" class="post-date">Thu, Mar 26, 2020</time>
  目录  identityserver4源码解析_1_项目结构 identityserver4源码解析_2_元数据接口 identityserver4源码解析_3_认证接口 identityserver4源码解析_4_令牌发放接口 identityserver4源码解析_5_查询用户信息接口 identityserver4源码解析_6_结束会话接口 identityserver4源码解析_7_查询令牌信息接口 identityserver4源码解析_8_撤销令牌接口  简介 Security源码解析系列介绍了微软提供的各种认证架构，其中OAuth2.0，OpenIdConnect属于远程认证架构，所谓远程认证，是指token的颁发是由其他站点完成的。
IdentityServer4是基于OpenIdConnect协议的认证中心框架，可以帮助我们快速搭建微服务认证中心。
初学者可能看到生涩的概念比较头疼，可以将OAuth, OpenIdConnect协议简单理解成需求文档，idsv4基于需求提供了一系列的api实现。
对于idsv还不太了解的可以看下面的资料，本系列主要学习梳理idsv4的源码，结合协议加深理解。
晓晨姐姐系列文章
 https://www.cnblogs.com/stulzq/p/8119928.html
 官方文档
 https://identityserver4.readthedocs.io/en/latest/
 项目结构 项目地址如下
 https://github.com/IdentityServer/IdentityServer4
 克隆到本地，项目结构如图
核心项目是IdentityServer4，其余的都是与微软框架集成、以及处理持久化的项目。 项目结构如图。Endpoints文件夹就是接口文件，我们先看下依赖注入、中间件的代码，然后看下每个接口。 依赖注入 public static IIdentityServerBuilder AddIdentityServer(this IServiceCollection services) { var builder = services.AddIdentityServerBuilder(); builder .AddRequiredPlatformServices() .AddCookieAuthentication() .AddCoreServices() .AddDefaultEndpoints() .AddPluggableServices() .AddValidators() .AddResponseGenerators() .AddDefaultSecretParsers() .AddDefaultSecretValidators(); // provide default in-memory implementation, not suitable for most production scenarios  builder.AddInMemoryPersistedGrants(); return builder; }  AddRequiredPlatformServices - 注入平台服务  IHttpContextAccessor：HttpContext访问器 IdentityServerOptions：配置类    public static IIdentityServerBuilder AddRequiredPlatformServices(this IIdentityServerBuilder builder) { builder.
  
  
  <div class="read-more-link">
    <a href="/identityserver4%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_1_%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_8_authorization_%E6%8E%88%E6%9D%83%E6%A1%86%E6%9E%B6/">AspNetCore3.1_Secutiry源码解析_8_Authorization_授权框架</a>
  </h1>
  <time datetime="2020-03-26T16:23:56&#43;0800" class="post-date">Thu, Mar 26, 2020</time>
  目录  AspNetCore3.1_Secutiry源码解析_1_目录 AspNetCore3.1_Secutiry源码解析_2_Authentication_核心流程 AspNetCore3.1_Secutiry源码解析_3_Authentication_Cookies AspNetCore3.1_Secutiry源码解析_4_Authentication_JwtBear AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth AspNetCore3.1_Secutiry源码解析_6_Authentication_OpenIdConnect AspNetCore3.1_Secutiry源码解析_7_Authentication_其他 AspNetCore3.1_Secutiry源码解析_8_Authorization_授权框架  简介 开篇提到过，认证主要解决的是who are you，授权解决的是 are you allowed的问题。各种认证架构可以帮我们知道用户身份（claims），oauth等架构的scope字段能够控制api服务级别的访问权限，但是更加细化和多变的功能授权不是它们的处理范围。
微软的Authorization项目提供了基于策略的灵活的授权框架。
推荐看下面博客了解，我主要学习和梳理源码。
 https://www.cnblogs.com/RainingNight/p/authorization-in-asp-net-core.html
 依赖注入 注入了以下接口，提供了默认实现
 IAuthorizationService ：授权服务，主干服务 IAuthorizationPolicyProvider ： 策略提供类 IAuthorizationHandlerProvider：处理器提供类 IAuthorizationEvaluator：校验类 IAuthorizationHandlerContextFactory：授权上下文工厂 IAuthorizationHandler：授权处理器，这个是注入的集合，一个策略可以有多个授权处理器，依次执行 配置类：AuthorizationOptions  微软的命名风格还是比较一致的
Service：服务
Provider：某类的提供者 Evaluator：校验预处理类
Factory：工厂
Handler：处理器
Context：上下文
看源码的过程，不仅可以学习框架背后原理，还可以学习编码风格和设计模式，还是挺有用处的。
/// &lt;summary&gt; /// Adds authorization services to the specified &lt;see cref=&#34;IServiceCollection&#34; /&gt;. /// &lt;/summary&gt; /// &lt;param name=&#34;services&#34;&gt;The &lt;see cref=&#34;IServiceCollection&#34; /&gt; to add services to.&lt;/param&gt; /// &lt;returns&gt;The &lt;see cref=&#34;IServiceCollection&#34;/&gt; so that additional calls can be chained.
  
  
  <div class="read-more-link">
    <a href="/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_8_authorization_%E6%8E%88%E6%9D%83%E6%A1%86%E6%9E%B6/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_7_authentication_%E5%85%B6%E4%BB%96/">AspNetCore3.1_Secutiry源码解析_7_Authentication_其他</a>
  </h1>
  <time datetime="2020-03-26T13:23:27&#43;0800" class="post-date">Thu, Mar 26, 2020</time>
  目录  AspNetCore3.1_Secutiry源码解析_1_目录 AspNetCore3.1_Secutiry源码解析_2_Authentication_核心流程 AspNetCore3.1_Secutiry源码解析_3_Authentication_Cookies AspNetCore3.1_Secutiry源码解析_4_Authentication_JwtBear AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth AspNetCore3.1_Secutiry源码解析_6_Authentication_OpenIdConnect AspNetCore3.1_Secutiry源码解析_7_Authentication_其他 AspNetCore3.1_Secutiry源码解析_8_Authorization_授权框架  简介 Secutiry的认证目录还有这些项目，基本都是具体的OAuth2.0服务商或者其他用的比较少的认证架构，简单看一下，了解一下。
 Microsoft.AspNetCore.Authentication.Certificate Microsoft.AspNetCore.Authentication.Facebook Microsoft.AspNetCore.Authentication.Google Microsoft.AspNetCore.Authentication.MicrosoftAccount Microsoft.AspNetCore.Authentication.Negotiate Microsoft.AspNetCore.Authentication.Twitter Microsoft.AspNetCore.Authentication.WsFederation  OAuth2.0服务商 Facebook, Google,MicrosoftAccount这几个都可以归为一类，都是OAuth2.0的服务商。国内用的比较多的是QQ，Weixin。我们看一下Facebook的代码，其他的原理都是大同小异的，根据不同厂商的差异稍作调整就可以了。
Twitter似乎是用的OAuth1.0协议。
依赖注入 配置类: FacebookOptions,处理器类：FacebookHandler
public static class FacebookAuthenticationOptionsExtensions { public static AuthenticationBuilder AddFacebook(this AuthenticationBuilder builder) =&gt; builder.AddFacebook(FacebookDefaults.AuthenticationScheme, _ =&gt; { }); public static AuthenticationBuilder AddFacebook(this AuthenticationBuilder builder, Action&lt;FacebookOptions&gt; configureOptions) =&gt; builder.AddFacebook(FacebookDefaults.AuthenticationScheme, configureOptions); public static AuthenticationBuilder AddFacebook(this AuthenticationBuilder builder, string authenticationScheme, Action&lt;FacebookOptions&gt; configureOptions) =&gt; builder.AddFacebook(authenticationScheme, FacebookDefaults.DisplayName, configureOptions); public static AuthenticationBuilder AddFacebook(this AuthenticationBuilder builder, string authenticationScheme, string displayName, Action&lt;FacebookOptions&gt; configureOptions) =&gt; builder.
  
  
  <div class="read-more-link">
    <a href="/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_7_authentication_%E5%85%B6%E4%BB%96/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_6_authentication_openidconnect/">AspNetCore3.1_Secutiry源码解析_6_Authentication_OpenIdConnect</a>
  </h1>
  <time datetime="2020-03-25T21:33:12&#43;0800" class="post-date">Wed, Mar 25, 2020</time>
  目录  AspNetCore3.1_Secutiry源码解析_1_目录 AspNetCore3.1_Secutiry源码解析_2_Authentication_核心流程 AspNetCore3.1_Secutiry源码解析_3_Authentication_Cookies AspNetCore3.1_Secutiry源码解析_4_Authentication_JwtBear AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth AspNetCore3.1_Secutiry源码解析_6_Authentication_OpenIdConnect AspNetCore3.1_Secutiry源码解析_7_Authentication_其他 AspNetCore3.1_Secutiry源码解析_8_Authorization_授权框架  oidc简介 oidc是基于oauth2.0的上层协议。
OAuth有点像卖电影票的，只关心用户能不能进电影院，不关心用户是谁。而oidc则像身份证，扫描就可以上飞机，一次扫描，机场不仅能知道你是否能上飞机，还可以知道你的身份信息。
oidc兼容OAuth2.0, 可以实现跨顶级域的SSO(单点登录、登出)，下个系列要学习的IdentityServer4就是对oidc协议族的一个具体实现框架。
更多理论知识看下面的参考资料，本系列主要过下源码脉络
博客园
 https://www.cnblogs.com/linianhui/p/openid-connect-core.html
 协议
 https://openid.net/connect/
 依赖注入 默认架构名称是OpenIdConnect，处理器类是OpenIdConnectHandler，配置类是OpenIdConnectOptions
public static AuthenticationBuilder AddOpenIdConnect(this AuthenticationBuilder builder) =&gt; builder.AddOpenIdConnect(OpenIdConnectDefaults.AuthenticationScheme, _ =&gt; { }); public static AuthenticationBuilder AddOpenIdConnect(this AuthenticationBuilder builder, Action&lt;OpenIdConnectOptions&gt; configureOptions) =&gt; builder.AddOpenIdConnect(OpenIdConnectDefaults.AuthenticationScheme, configureOptions); public static AuthenticationBuilder AddOpenIdConnect(this AuthenticationBuilder builder, string authenticationScheme, Action&lt;OpenIdConnectOptions&gt; configureOptions) =&gt; builder.AddOpenIdConnect(authenticationScheme, OpenIdConnectDefaults.DisplayName, configureOptions); public static AuthenticationBuilder AddOpenIdConnect(this AuthenticationBuilder builder, string authenticationScheme, string displayName, Action&lt;OpenIdConnectOptions&gt; configureOptions) { builder.
  
  
  <div class="read-more-link">
    <a href="/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_6_authentication_openidconnect/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_5_authentication_oauth/">AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth</a>
  </h1>
  <time datetime="2020-03-24T23:27:45&#43;0800" class="post-date">Tue, Mar 24, 2020</time>
  目录  AspNetCore3.1_Secutiry源码解析_1_目录 AspNetCore3.1_Secutiry源码解析_2_Authentication_核心流程 AspNetCore3.1_Secutiry源码解析_3_Authentication_Cookies AspNetCore3.1_Secutiry源码解析_4_Authentication_JwtBear AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth AspNetCore3.1_Secutiry源码解析_6_Authentication_OpenIdConnect AspNetCore3.1_Secutiry源码解析_7_Authentication_其他 AspNetCore3.1_Secutiry源码解析_8_Authorization_授权框架  OAuth简介 现在随便一个网站，不用注册，只用微信扫一扫，然后就可以自动登录，然后第三方网站右上角还出现了你的微信头像和昵称，怎么做到的？
sequenceDiagram 用户-x站点: 请求微信登录 x站点-微信: 请求 oauth token 微信-用户: x站点请求基本资料权限,是否同意? 用户-微信: 同意 微信-x站点: token x站点-微信: 请求user基本资料(token) 微信-微信: 校验token 微信-x站点: user基本资料   大概就这么个意思，OAuth可以让第三方获取有限的授权去获取资源。
入门的看博客
 https://www.cnblogs.com/linianhui/p/oauth2-authorization.html
 英文好有基础的直接看协议
 https://tools.ietf.org/html/rfc6749
 依赖注入 配置类：OAuthOptions
处理器类： OAuthHandler
public static class OAuthExtensions { public static AuthenticationBuilder AddOAuth(this AuthenticationBuilder builder, string authenticationScheme, Action&lt;OAuthOptions&gt; configureOptions) =&gt; builder.AddOAuth&lt;OAuthOptions, OAuthHandler&lt;OAuthOptions&gt;&gt;(authenticationScheme, configureOptions); public static AuthenticationBuilder AddOAuth(this AuthenticationBuilder builder, string authenticationScheme, string displayName, Action&lt;OAuthOptions&gt; configureOptions) =&gt; builder.
  
  
  <div class="read-more-link">
    <a href="/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_5_authentication_oauth/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_4_authentication_jwtbear/">AspNetCore3.1_Secutiry源码解析_4_Authentication_JwtBear</a>
  </h1>
  <time datetime="2020-03-22T16:29:29&#43;0800" class="post-date">Sun, Mar 22, 2020</time>
  目录  AspNetCore3.1_Secutiry源码解析_1_目录 AspNetCore3.1_Secutiry源码解析_2_Authentication_核心流程 AspNetCore3.1_Secutiry源码解析_3_Authentication_Cookies AspNetCore3.1_Secutiry源码解析_4_Authentication_JwtBear AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth AspNetCore3.1_Secutiry源码解析_6_Authentication_OpenIdConnect AspNetCore3.1_Secutiry源码解析_7_Authentication_其他 AspNetCore3.1_Secutiry源码解析_8_Authorization_授权框架  JwtBear简介 首先回想一下Cookie认证，Cookie认证在用户登录成功之后将用户信息加密后写入浏览器Cookie中，服务端通过解析Cookie内容来验证用户登录状态。这样做有几个缺陷：
 Cookie加密方式是微软自己定义的，并非国际标准，其他语言无法识别。 依赖Cookie，在跨域场景下，存在诸多限制。  CORS除非设置白名单否则是不允许带Cookie的； 大部分浏览器对跨域设置Cookie有严格的限制。比如：A网站使用iframe嵌套B网站来实现集成，B网站依赖Cookie来维持登录态，如果是Chrome浏览器，需要将Cookie的Secure设置为true，即必须使用https，同时将SameSite设置为None，这样可以解决问题但是存在跨站访问攻击（CSRF）的安全漏洞，而Safari则是完全禁止设置跨站Cookie的）    JwtBear可以解决上面的缺点
 Jwt是国际标准 Jwt不依赖Cookie，不存在跨站访问攻击问题  依赖注入 提供了四个重载方法，主要设置配置类 JwtBearerOptions。 默认添加名称为Bearer的认证Schema，JwtBearerHandler为处理器类。
public static class JwtBearerExtensions { public static AuthenticationBuilder AddJwtBearer(this AuthenticationBuilder builder) =&gt; builder.AddJwtBearer(JwtBearerDefaults.AuthenticationScheme, _ =&gt; { }); public static AuthenticationBuilder AddJwtBearer(this AuthenticationBuilder builder, Action&lt;JwtBearerOptions&gt; configureOptions) =&gt; builder.AddJwtBearer(JwtBearerDefaults.AuthenticationScheme, configureOptions); public static AuthenticationBuilder AddJwtBearer(this AuthenticationBuilder builder, string authenticationScheme, Action&lt;JwtBearerOptions&gt; configureOptions) =&gt; builder.
  
  
  <div class="read-more-link">
    <a href="/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_4_authentication_jwtbear/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_3_authentication_cookies/">AspNetCore3.1_Secutiry源码解析_3_Authentication_Cookies</a>
  </h1>
  <time datetime="2020-03-19T22:52:39&#43;0800" class="post-date">Thu, Mar 19, 2020</time>
  目录  AspNetCore3.1_Secutiry源码解析_1_目录 AspNetCore3.1_Secutiry源码解析_2_Authentication_核心流程 AspNetCore3.1_Secutiry源码解析_3_Authentication_Cookies AspNetCore3.1_Secutiry源码解析_4_Authentication_JwtBear AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth AspNetCore3.1_Secutiry源码解析_6_Authentication_OpenIdConnect AspNetCore3.1_Secutiry源码解析_7_Authentication_其他 AspNetCore3.1_Secutiry源码解析_8_Authorization_授权框架  依赖注入 AuthenticationBuilder AddCookie(this AuthenticationBuilder builder); AuthenticationBuilder AddCookie(this AuthenticationBuilder builder, string authenticationScheme); AuthenticationBuilder AddCookie(this AuthenticationBuilder builder, Action&lt;CookieAuthenticationOptions&gt; configureOptions); 提供了几个重载方法，可以使用默认配置，或者通过委托修改配置类CookieAuthenticationOptions的值。
可以定义登录、登出、拒绝登录页面地址、Cookie过期时间、生命周期各阶段事件等。
classDiagram class CookieAuthenticationOptions{ CookieBuilder Cookie IDataProtectionProvider DataProtectionProvider bool SlidingExpiration PathString LoginPath PathString LogoutPath PathString AccessDeniedPath CookieAuthenticationEvents Events ISecureDataFormat TicketDataFormat ITicketStore SessionStore TimeSpan ExpireTimeSpan } class AuthenticationSchemeOptions{ string ClaimsIssuer object Events Type EventsType string ForwardDefault string ForwardAuthenticate string ForwardChallenge string ForwardForbid string ForwardSignIn string ForwardSignOut Func ForwardDefaultSelector } CookieAuthenticationOptions--AuthenticationSchemeOptions   如果没有定义配置，则会使用CookieAuthenticationDefaults定义的默认配置
  
  
  <div class="read-more-link">
    <a href="/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_3_authentication_cookies/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_2_authentication_%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/">AspNetCore3.1_Secutiry源码解析_2_Authentication_核心流程</a>
  </h1>
  <time datetime="2020-03-18T21:19:15&#43;0800" class="post-date">Wed, Mar 18, 2020</time>
  目录  AspNetCore3.1_Secutiry源码解析_1_目录 AspNetCore3.1_Secutiry源码解析_2_Authentication_核心流程 AspNetCore3.1_Secutiry源码解析_3_Authentication_Cookies AspNetCore3.1_Secutiry源码解析_4_Authentication_JwtBear AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth AspNetCore3.1_Secutiry源码解析_6_Authentication_OpenIdConnect AspNetCore3.1_Secutiry源码解析_7_Authentication_其他 AspNetCore3.1_Secutiry源码解析_8_Authorization_授权框架  依赖注入 框架提供了三个依赖注入重载方法。
//注入认证服务 services.AddAuthentication(); //注入认证服务并制定默认架构名 services.AddAuthentication(&#34;Cookies&#34;); //注入认证服务并设置配置项 services.AddAuthentication(config =&gt; { }); 看看注入代码
public static AuthenticationBuilder AddAuthentication(this IServiceCollection services) { if (services == null) { throw new ArgumentNullException(nameof(services)); } services.AddAuthenticationCore(); services.AddDataProtection(); services.AddWebEncoders(); services.TryAddSingleton&lt;ISystemClock, SystemClock&gt;(); return new AuthenticationBuilder(services); } AddAuthenticationCore注入了认证服务的核心对象。这个方法在Authentication.Core项目，这个项目定义了认证服务的核心对象，在Authentication.Abstractions项目中定义了核心接口。
AddAuthenticationCore方法注入了IAuthenticationService，IClaimsTransformation，IAuthenticationHandlerProvider，IAuthenticationSchemeProvider
public static IServiceCollection AddAuthenticationCore(this IServiceCollection services) { if (services == null) { throw new ArgumentNullException(nameof(services)); } services.TryAddScoped&lt;IAuthenticationService, AuthenticationService&gt;(); services.TryAddSingleton&lt;IClaimsTransformation, NoopClaimsTransformation&gt;(); // Can be replaced with scoped ones that use DbContext  services.
  
  
  <div class="read-more-link">
    <a href="/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_2_authentication_%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_1_%E7%9B%AE%E5%BD%95/">AspNetCore3.1_Secutiry源码解析_1_目录</a>
  </h1>
  <time datetime="2020-03-17T23:01:38&#43;0800" class="post-date">Tue, Mar 17, 2020</time>
  目录  AspNetCore3.1_Secutiry源码解析_1_目录 AspNetCore3.1_Secutiry源码解析_2_Authentication_核心流程 AspNetCore3.1_Secutiry源码解析_3_Authentication_Cookies AspNetCore3.1_Secutiry源码解析_4_Authentication_JwtBear AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth AspNetCore3.1_Secutiry源码解析_6_Authentication_OpenIdConnect AspNetCore3.1_Secutiry源码解析_7_Authentication_其他 AspNetCore3.1_Secutiry源码解析_8_Authorization_授权框架  概述 最近一直在学习研究认证授权这一块，从AspNetCore的Security解决方案，到Identity，再到OAuth2.0、OpenIdConnect协议，然后IdentityServer4，这一块的东西十分多而且复杂，可以算是DotNet里最难啃的骨头之一了。计划做个认证授权的系列，藉由分析源码来学习、记录和加深对这一块的理解。
如图是AspNetCore.Security解决方案的项目结构。
可以看到主要有5个解决方案文件夹
 Authentication：认证 Authorization：授权 CookiePolicy：Cookie策略中间件 _dependencies：依赖项目 benchmarks：测试项目  最主要的是Authentication和Authorization这两个里面的内容。
什么是Authentication， 什么是Authorization 初次接触这一块，可能会比较懵，啥玩意儿啊，俩单词长得差不多像念绕口令的。
我尝试大白话解释下。
Authentication（认证）：who are you。系统获知当前用户身份的过程就叫认证。可以类比成身份证。通常来说，在你登录的时候，系统就知道了你的身份，然后将当前用户信息加密后存储在Cookie中来维持登录态。
Authorization（授权）：are you allowed。授权就是判断你有没有权限，比如网管拿着你身份证一看，你这不行，未满十八岁，不能在我这上网。而有的黑网吧是没有这个要求的，给钱就能玩。正经网吧和黑网吧，这就是需要授权资源和匿名资源的区别。
Authentication项目简介 我们可以看到第三个文件夹叫Core，里面只有一个项目叫Microsoft.AspNetCore.Authentication，是我们使用DotNet授权框架必须引用的一个核心类库。
然后其他的Certificate、Cookies、OAuth、OpenIdConnect等这些，在DotNet里叫做Schema，可以翻译为架构。这就好比，证明身份的方式有很多种，身份证、护照、户口本都可以，同理网络世界也有各种各样的协议。最常见传统的是方式是使用Cookie，也可以使用无状态的JwtBear，现在常见的微信、QQ等扫码登录是使用的OAuth协议。
Authorization项目简介 授权就两个项目，[Microsoft.AspNetCore.Authorization.Policy],[Microsoft.AspNetCore.Authorization]。多看看源码的话，应该对Policy这个词很熟悉了，在DotNet里面属于高频词汇，意思是策略。这两个项目允许设置不同的授权策略/规则，来实现高度灵活的授权方案。
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_middleware%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_4_staticfiles/">AspNetCore3.1_Middleware源码解析_4_StaticFiles</a>
  </h1>
  <time datetime="2020-03-16T21:59:17&#43;0800" class="post-date">Mon, Mar 16, 2020</time>
  概述 AspNetCore提供了StaticFiles中间件，使我们可以轻松访问静态文件。
使用方法 AspNetCore提供了三个重载方法，没有特殊需求的情况下，我们使用无参的就可以了。
//使用默认配置 app.UseStaticFiles(); //自定义静态资源相对路径 app.UseStaticFiles(&#34;/MyCustomStaticFilePath&#34;); //所有可以配置的选项 app.UseStaticFiles(new StaticFileOptions { //用于映射file的content-type  ContentTypeProvider = null, //ContentTypeProvider无法决定content-type时的默认content-type  DefaultContentType = null, //文件提供程序  FileProvider = new PhysicalFileProvider(&#34;/&#34;), //Https请求，ResponseCompression中间件启用的情况下，是否对返回值压缩  HttpsCompression = Microsoft.AspNetCore.Http.Features.HttpsCompressionMode.Compress, //委托，状态码和Headers设置完，Body写入前触发，可用于修改响应头  OnPrepareResponse = null, //映射静态资源的相对路径  RequestPath = &#34;/MyStaticFiles&#34;, //是否伺服未知文件类型  ServeUnknownFileTypes = false }); TO BE CONTINUE&hellip;
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_middleware%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_3_httpsredirection/">AspNetCore3.1_Middleware源码解析_3_HttpsRedirection</a>
  </h1>
  <time datetime="2020-03-16T18:20:41&#43;0800" class="post-date">Mon, Mar 16, 2020</time>
  概述 上文提到3.1版本默认没有使用Hsts，但是使用了HttpsRedirection这个中间件。看名字就很好理解，https跳转，顾名思义，就是跳转到https地址。
使用场景：当用户使用http访问网站时，自动跳转到https地址。这样更加安全，也更加方便，因为不需要用户特意输入https://。
具体怎么实现的我们来看看。
app.UseHttpsRedirection(); 使用方法 跟Hsts一样，HttpsRedirection默认是不需要注入的，除非你需要修改默认配置。
services.AddHttpsRedirection(config =&gt; { //https地址的端口号，默认null  config.HttpsPort = 12345; //跳转响应的状态码，默认307  config.RedirectStatusCode = 302; }); 直接使用中间件即可
app.UseHttpsRedirection(); 源码解析 源代码很简单，只有两个类：HttpsRedirectionOptions配置类，HttpsRedirectionMiddleware中间件
HttpsRedirectionOptions就只有两个配置项
/// &lt;summary&gt;  /// Options for the HttpsRedirection middleware  /// &lt;/summary&gt;  public class HttpsRedirectionOptions { /// &lt;summary&gt;  /// The status code used for the redirect response. The default is 307.  /// &lt;/summary&gt;  public int RedirectStatusCode { get; set; } = StatusCodes.
  
  
  <div class="read-more-link">
    <a href="/aspnetcore3.1_middleware%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_3_httpsredirection/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_middleware%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_2_hsts/">AspNetCore3.1_Middleware源码解析_2_Hsts</a>
  </h1>
  <time datetime="2020-03-16T12:40:46&#43;0800" class="post-date">Mon, Mar 16, 2020</time>
  概述 在DotNetCore2.2版本中，当你新增一个WebAPI项目，Startup.cs文件中，会有这么一行代码（3.1版本默认没有使用该中间件）。
if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } else { // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.  app.UseHsts(); } 这段代码，翻译一下就是开发环境使用开发异常页面，其他环境使用Hsts中间件。这个Hsts中间件是个什么东西呢，今天来看一看。
HSTS是什么 HTTP严格传输安全协议（英语：HTTP Strict Transport Security，简称：HSTS）。
简单描述一下协议内容，就是出于安全考虑，强制客户端使用https与服务端连接。
为什么要这么做呢，比较学术和系统的论述自行查看下面的链接。我这里举个通俗的栗子。
首先我们知道http是不安全的，而https是安全的，它能保障你访问的A网站就是A，而不是什么其他的野鸡。
某一天，你去逛淘宝，你往chrome地址栏敲 taobao.com，正常情况下岁月安好，什么问题都没有。假如，这时候你接入的是公共免费wifi，而这背后有人搞鬼，或者说你的电脑已经中了病毒，它可以将你跳转到一个跟taobao一模一样的网站 (怎么做到的？比如修改你的host文件，将taobao域名指向他自己搭建的假taobao网站ip)，浏览器并不知道taobao需要使用https访问，所以无法保护你，你的钱就在你的鼠标点击下，跟随着一个个http请求流入到了黑客的账户。
那要怎么办呢，不上公共wifi行不行，行，但是防不胜防，不是根本的办法。 那我们告诉浏览器taobao需要用https访问行不行，听起来不错，那怎么告诉呢，我们来搞个协议，这个协议就是HSTS。
一句话描述HTST：当你首次使用https访问了taobao成功后，taobao会返回Strict-Transport-Security头，表明我这个网站需要使用https访问，浏览器记录下这个信息，以后taobao的请求都会使用https，因此堵住了上面案例的安全漏洞。
 https://baike.baidu.com/item/HTTP%E4%B8%A5%E6%A0%BC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/16018283?fromtitle=HSTS&amp;fromid=8665782&amp;fr=aladdin
  https://developer.mozilla.org/zh-CN/docs/Security/HTTP_Strict_Transport_Security
  https://tools.ietf.org/html/rfc6797
 HSTS中间件的使用 通常，我们不需要写Hsts的注入代码，因为它没有任何需要注入的服务。除非你需要修改它的默认配置。
services.AddHsts(config =&gt; { //是否包含子域名，默认false  config.IncludeSubDomains = true; //有效时长，默认30天  config.MaxAge = TimeSpan.FromDays(365); }); 然后，使用中间件即可。
  
  
  <div class="read-more-link">
    <a href="/aspnetcore3.1_middleware%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_2_hsts/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_middleware%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_1_cors/">AspNetCore3.1_Middleware源码解析_1_CORS</a>
  </h1>
  <time datetime="2020-03-15T17:26:10&#43;0800" class="post-date">Sun, Mar 15, 2020</time>
  概述 什么是跨域 在前后端分离开发方式中，跨域是我们经常会遇到的问题。所谓的跨域，就是出于安全考虑，A域名向B域名发出Ajax请求，浏览器会拒绝，抛出类似下图的错误。
JSONP JSONP不是标准跨域协议，更像是聪明程序员投机取巧的办法。这种方式的原理就是js是没有跨域限制的，你想想你引用bootstrap.js是不是网络地址放进来就可以用了。
实际上，所有src属性都不限制跨域的，比如img标签使用跨域图片是不会有问题的。
过程大体分下面四步。
 首先约定数据格式和回调函数名 A网站引用B网站的js B网站用约定好的回调函数将数据包裹起来，在A引用的js里返回 A网站在回调函数中获取数据  这个方案的优点是兼容性比较好，古老版本的IE都可以支持，毕竟只是基于js的一个技巧，并没有新的技术或协议。
缺点比较明显，只支持GET，理解起来比较别扭，调用失败不会返回http状态码，安全性存在一定问题。
CORS CORS的全称是Cross Origin Resource Sharing，翻译过来就是跨域资源共享。
跨域问题本质就是浏览器处于安全考虑，阻止了客户端跨域请求。但说到底，客户端请求安不安全还不是服务端说了算的，服务端都说我们家大米你们随便吃，浏览器还阻止，这不是碍事吗，你个物业还当自己业主啦？
但是浏览器也不能随便放行，毕竟网上冲浪的不仅有正经客人，还有小偷，真出问题了还得吐槽物业稀烂。浏览器说，服务端，这个客户端要去你家吃大米，你得告诉我你同不同意啊，服务端说我咋告诉你啊，我总不能来个人就冲着岗亭喊 I&rsquo;M OK吧。浏览器说那我们搞个协议吧，整个互联网小区都按这个规范来，你们就按这个格式回复我。
这个协议就是CORS了。
下图描述了简单请求的流程。
graph LR; A(客户端)--B(不带Orgin跨域请求); B--C(浏览器拒绝); A--D(带Origin跨域请求); D--E(服务端返回白名单); E--F(白名单内); E--G(白名单外); F--H(浏览器放行); G--C    关于CORS简单请求，复杂请求，以及详细内容参考下面文章，不再赘述。 http://www.ruanyifeng.com/blog/2016/04/cors.html
 CORS的缺点就是IE10以下不支持，如果你的项目需要兼容这些浏览器的话需要注意。
怎么实现CORS CORS说白了其实就是在响应头里加东西，你可以在运维环节比如nginx加，可以在代码里加，常见的做法是中间件统一处理。AspNetCore为我们提供了CORS中间件。
AspNetCore_CORS中间件的使用 使用CORS中间件两句代码就够了,在Startup文件中
//注入CORS相关的服务，配置跨域策略 public void ConfigureServices(IServiceCollection services) { //策略1，允许所有域名跨域访问  config.AddPolicy(&#34;policy1&#34;, policy =&gt; { policy.AllowAnyOrigin(). AllowAnyMethod(). AllowAnyOrigin(). AllowAnyMethod(); //注意：AllowAnyOrigin和AllowCredential不能同时出现，否则会报错  //AllowCredential即是否允许客户端发送cookie，基于安全原因，CORS协议规定不允许AllowOrigin为通配符的情况下设置允许发送cookie  //.AllowCredentials();  }); //策略2，仅允许特定域名、方法、请求头访问  config.
  
  
  <div class="read-more-link">
    <a href="/aspnetcore3.1_middleware%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_1_cors/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_2_%E4%BD%BF%E7%94%A8webhook%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/">构建个人博客-2-使用Webhook自动发布</a>
  </h1>
  <time datetime="2020-03-14T21:15:28&#43;0800" class="post-date">Sat, Mar 14, 2020</time>
  概述 上篇介绍了怎么利用hugo搭建个人博客。 有一个地方还是有点不方便，就是git push之后需要等半个小时才能发布。
所以我想利用github的webhook实现每次推送自动发布。
github设置钩子 所谓的webhook,就是钩子,就是github搞事情的时候就会通知你。所以你需要准备一个接口接收github的post请求。 这里我设置为接收json格式数据，仅push时通知。 编写接口 生产环境一般是使用Travis Ci或者Jenkins来实现类似功能，但这对于我来说有点重型了。所以自己写个接口简单实现下。 需求很简单，每当有代码推送的时候，拉取git并发布到blog部署目录。
我这里使用.net core实现，代码十分简单，其实就一行，执行blog.sh脚本。
再看下这个blog.sh脚本的内容，也很简单，首先拉取git内容，再拷贝到部署目录就行了。
#!/bin/bash cd /git/blog git pull cp -rf /git/blog/public/. /www/wwwroot/www.holdengong.com/ 这里有3个小坑要注意
 第一行的 #!/bin/bash 是必须的 脚本必须是ANSI编码 需要执行命令 chmod +x blog.sh 是脚本可执行  完成 大功告成。接下来可以愉快的写日志了，写完只需要签入，自动发布，爽！
 这篇博客由系统自动发布
 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_1_%E4%BD%BF%E7%94%A8hugo%E5%BF%AB%E9%80%9F%E6%88%90%E5%9E%8B/">构建个人博客_1_使用Hugo快速成型</a>
  </h1>
  <time datetime="2020-03-14T14:42:38&#43;0800" class="post-date">Sat, Mar 14, 2020</time>
  概述 人在武汉，病毒肆虐。
隔离久了，有点闷，闲余时间找点事情做。
建个博客吧， 内容不重要，写不写也不那么要紧，目前水平也写不出什么有深度的东西。
但是这个姿势一定要优美， 过程一定要折腾。
OK, 开干。
下载Hugo  https://github.com/gohugoio/hugo/releases
 笔者是Windows系统，下载hugo_0.67.0_Windows-64bit.zip，解压到本地后，将路径加入到环境变量。
创建站点 首先创建一个git仓库
拉取到本地
如文件夹名为blog
cd blog hugo new site . 编写正文 hugo new hello-world.md 下载主题 cd theme git clone https://github.com/spf13/hyde.git 调试 hugo server --theme=hyde --buildDrafts 然后浏览器打开 http://localhost1313 可以查看效果
发布 发布前将hello-world.md的draft字段修改为true, https://holdengong.com/ 为你网站的域名
hugo --theme=hyde -b https://holdengong.com/ 执行完后会发现生成了public文件夹及内容
部署 云服务器可以使用腾讯云的学生版  https://cloud.tencent.com/act/campus?fromSource=gwzcw.2432501.2432501.2432501&amp;utm_medium=cpc&amp;utm_id=gwzcw.2432501.2432501.2432501
 安装宝塔面板linux管理工具  https://www.bt.cn/
 安装git yum -y install git 拉取git仓库, e.g.仓库目录为/git/blog
宝塔新建站点 e.g.站点根路由为/www/wwwroot/www.holdengong.com
定时发布 利用linux的定时任务做一个简单的定时发布
  
  
  <div class="read-more-link">
    <a href="/%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_1_%E4%BD%BF%E7%94%A8hugo%E5%BF%AB%E9%80%9F%E6%88%90%E5%9E%8B/">Read More…</a>
  </div>
  
</article>
</div>
    </main>

    
      
    
  </body>
</html>
