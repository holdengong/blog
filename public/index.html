<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-Hans" lang="zh-Hans">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.67.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Holden Gong</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://holdengong.com/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://holdengong.com/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://holdengong.com/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://holdengong.com/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="https://holdengong.com/index.xml" rel="alternate" type="application/rss+xml" title="Holden Gong" />
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://holdengong.com/">
        <h1>Holden Gong</h1>
      </a>
      <p class="lead">
        code & life
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
  
      </ul>
    </nav>
    
    <div>
      
      <p>&copy; 2020. All rights reserved. </p>
      <p>鄂ICP备20003133号</p>
    </div>
  </div>
</aside>

    <main class="content container">
    <div class="posts">
<article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_1_cors%E4%B8%AD%E9%97%B4%E4%BB%B6/">AspNetCore源码解析_1_CORS中间件</a>
  </h1>
  <time datetime="2020-03-15T17:26:10&#43;0800" class="post-date">Sun, Mar 15, 2020</time>
  概述 什么是跨域 在前后端分离开发方式中，跨域是我们经常会遇到的问题。所谓的跨域，就是处于安全考虑，A域名向B域名发出Ajax请求，浏览器会拒绝，抛出类似下图的错误。
JSONP JSONP不是标准跨域协议，更像是聪明程序员投机取巧的办法。这种方式的原理就是js是没有跨域限制的，你想想你引用bootstrap.js是不是网络地址放进来就可以用了。
实际上，所有src属性都不限制跨域的，比如img标签使用跨域图片是不会有问题的。
过程大体分下面四步。
 首先约定数据格式和回调函数名 A网站引用B网站的js B网站用约定好的回调函数将数据包裹起来，在A引用的js里返回 A网站在回调函数中获取数据  这个方案的优点是兼容性比较好，很古老的ie都可以支持，毕竟只是基于js的一个技巧，并没有新的技术或协议。
缺点比较明显，只支持GET，理解起来比较别扭，调用失败不会返回http状态码，安全性存在一定问题。
CORS CORS的全称是Cross Origin Resource Sharing，翻译过来就是跨域资源共享。
跨域问题本质就是浏览器处于安全考虑，阻止了客户端跨域请求。但说到底，客户端请求安不安全还不是服务端说了算的，服务端都说我们家大米你们随便吃，浏览器还阻止，这不是碍事吗，你个物业还当自己业主啦？
但是浏览器也不能随便放行，毕竟网上冲浪的不仅有正经客人，还有小偷，真出问题了还得吐槽物业稀烂。浏览器说，服务端，这个客户端要去你家吃大米，你得告诉我你同不同意啊，服务端说我咋告诉你啊，我总不能来个人就冲着岗亭喊 I&rsquo;M OK吧。浏览器说那我们搞个协议吧，整个互联网小区都按这个规范来，你们就按这个格式回复我。
这个协议就是CORS了。
graph LR; A(客户端)--&gt;B(不带Orgin跨域请求); B--&gt;C(浏览器拒绝); A--&gt;D(带Origin跨域请求); D--&gt;E(服务端返回白名单); E--&gt;F(白名单内); E--&gt;G(白名单外); F--&gt;H(浏览器放行); G--&gt;C CORS的缺点就是IE10以下不支持，如果你的项目需要兼容这些浏览器的话需要注意。
关于CORS协议详细的内容看这篇文章
 http://www.ruanyifeng.com/blog/2016/04/cors.html
 怎么实现CORS CORS说白了其实就是在响应头里加东西，你可以在运维环节比如nginx加，可以在代码里加，常见的做法是中间件统一处理。AspNetCore为我们提供了CORS中间件。
AspNetCore_CORS中间件的使用 使用CORS中间件两句代码就够了,在Startup文件中
//注入CORS相关的服务，配置跨域策略 [CorsPolicy] public void ConfigureServices(IServiceCollection services) { services.AddCors(config=&gt; { config.AddPolicy(&#34;CorsPolicy&#34;, policy =&gt; { policy.AllowAnyOrigin(). AllowAnyMethod(). AllowAnyOrigin(). AllowAnyMethod(); /*注意：AllowAnyOrigin和AllowCredential不能同时出现.否则会报错AllowCredential即是否允许客户端发送cookie，基于安全原因，CORS协议规定不允许AllowOrigin为通配符的情况下设置允许发送cookie .AllowCredentials();*/ }); }); } //使用CORS中间件, 指定使用CorsPolicy public void Configure(IApplicationBuilder app) { app.
  
  
  <div class="read-more-link">
    <a href="/aspnetcore%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_1_cors%E4%B8%AD%E9%97%B4%E4%BB%B6/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_2_%E4%BD%BF%E7%94%A8webhook%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/">构建个人博客-2-使用Webhook自动发布</a>
  </h1>
  <time datetime="2020-03-14T21:15:28&#43;0800" class="post-date">Sat, Mar 14, 2020</time>
  概述 上篇介绍了怎么利用hugo搭建个人博客。 有一个地方还是有点不方便，就是git push之后需要等半个小时才能发布。
所以我想利用github的webhook实现每次推送自动发布。
github设置钩子 所谓的webhook,就是钩子,就是github搞事情的时候就会通知你。所以你需要准备一个接口接收github的post请求。 这里我设置为接收json格式数据，仅push时通知。 编写接口 生产环境一般是使用Travis Ci或者Jenkins来实现类似功能，但这对于我来说有点重型了。所以自己写个接口简单实现下。 需求很简单，每当有代码推送的时候，拉取git并发布到blog部署目录。
我这里使用.net core实现，代码十分简单，其实就一行，执行blog.sh脚本。
再看下这个blog.sh脚本的内容，也很简单，首先拉取git内容，再拷贝到部署目录就行了。
#!/bin/bash cd /git/blog git pull cp -rf /git/blog/public/. /www/wwwroot/www.holdengong.com/ 这里有3个小坑要注意
 第一行的 #!/bin/bash 是必须的 脚本必须是ANSI编码 需要执行命令 chmod +x blog.sh 是脚本可执行  完成 大功告成。接下来可以愉快的写日志了，写完只需要签入，自动发布，爽！
 这篇博客由系统自动发布
 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_1_%E4%BD%BF%E7%94%A8hugo%E5%BF%AB%E9%80%9F%E6%88%90%E5%9E%8B/">1构建个人博客--使用Hugo快速成型</a>
  </h1>
  <time datetime="2020-03-14T14:42:38&#43;0800" class="post-date">Sat, Mar 14, 2020</time>
  概述 人在武汉，病毒肆虐。
隔离久了，有点闷，闲余时间找点事情做。
建个博客吧， 内容不重要，写不写也不那么要紧，目前水平也写不出什么有深度的东西。
但是这个姿势一定要优美， 过程一定要折腾。
OK, 开干。
下载Hugo  https://github.com/gohugoio/hugo/releases
 笔者是Windows系统，下载hugo_0.67.0_Windows-64bit.zip，解压到本地后，将路径加入到环境变量。
创建站点 首先创建一个git仓库
拉取到本地
如文件夹名为blog
cd blog hugo new site . 编写正文 hugo new hello-world.md 下载主题 cd theme git clone https://github.com/spf13/hyde.git 调试 hugo server --theme=hyde --buildDrafts 然后浏览器打开 http://localhost1313 可以查看效果
发布 发布前将hello-world.md的draft字段修改为true, https://holdengong.com/ 为你网站的域名
hugo --theme=hyde -b https://holdengong.com/ 执行完后会发现生成了public文件夹及内容
部署 云服务器可以使用腾讯云的学生版  https://cloud.tencent.com/act/campus?fromSource=gwzcw.2432501.2432501.2432501&amp;utm_medium=cpc&amp;utm_id=gwzcw.2432501.2432501.2432501
 安装宝塔面板linux管理工具  https://www.bt.cn/
 安装git yum -y install git 拉取git仓库, e.g.仓库目录为/git/blog
宝塔新建站点 e.g.站点根路由为/www/wwwroot/www.holdengong.com
定时发布 利用linux的定时任务做一个简单的定时发布
  
  
  <div class="read-more-link">
    <a href="/%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_1_%E4%BD%BF%E7%94%A8hugo%E5%BF%AB%E9%80%9F%E6%88%90%E5%9E%8B/">Read More…</a>
  </div>
  
</article>
</div>
    </main>

    
      
    
  </body>
</html>
