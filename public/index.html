<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-Hans" lang="zh-Hans">
<head>
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.67.0" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Holden Gong</title>
  <meta name="description" content="" />

  
  <link type="text/css" rel="stylesheet" href="https://holdengong.com/css/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="https://holdengong.com/css/poole.css">
  <link type="text/css" rel="stylesheet" href="https://holdengong.com/css/syntax.css">
  <link type="text/css" rel="stylesheet" href="https://holdengong.com/css/hyde.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="https://holdengong.com/index.xml" rel="alternate" type="application/rss+xml" title="Holden Gong" />
  
</head>

  <body class=" ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://holdengong.com/">
        <h1>Holden Gong</h1>
      </a>
      <p class="lead">
        code & life
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
  
      </ul>
    </nav>
    
    <div>
      <p>&copy; 2020. All rights reserved. </p>
      <p>鄂ICP备20003133号</p>
      <script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1278689390'%3E%3C/span%3E%3Cscript src='https://v1.cnzz.com/z_stat.php%3Fid%3D1278689390%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
    </div>
  </div>
</aside>

    <main class="content container">
    <div class="posts">
<article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_7_authentication_%E5%85%B6%E4%BB%96/">AspNetCore3</a>
  </h1>
  <time datetime="2020-03-26T13:23:27&#43;0800" class="post-date">Thu, Mar 26, 2020</time>
  系列文章目录  AspNetCore3.1_Secutiry源码解析_1_目录 AspNetCore3.1_Secutiry源码解析_2_Authentication_核心流程 AspNetCore3.1_Secutiry源码解析_3_Authentication_Cookies AspNetCore3.1_Secutiry源码解析_4_Authentication_JwtBear AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth AspNetCore3.1_Secutiry源码解析_6_Authentication_OpenIdConnect AspNetCore3.1_Secutiry源码解析_7_Authentication_其他 AspNetCore3.1_Secutiry源码解析_8_Authorization_核心项目 AspNetCore3.1_Secutiry源码解析_9_Authorization_Policy  简介 Secutiry的认证目录还有这些项目，基本都是具体的OAuth2.0服务商或者其他用的比较少的认证架构，简单看一下，了解一下。
 Microsoft.AspNetCore.Authentication.Certificate Microsoft.AspNetCore.Authentication.Facebook Microsoft.AspNetCore.Authentication.Google Microsoft.AspNetCore.Authentication.MicrosoftAccount Microsoft.AspNetCore.Authentication.Negotiate Microsoft.AspNetCore.Authentication.Twitter Microsoft.AspNetCore.Authentication.WsFederation  OAuth2.0服务商 Facebook, Google,MicrosoftAccount这几个都可以归为一类，都是OAuth2.0的服务商。国内用的比较多的是QQ，Weixin。我们看一下Facebook的代码，其他的原理都是大同小异的，根据不同厂商的差异稍作调整就可以了。
Twitter似乎是用的OAuth1.0协议。
依赖注入 配置类: FacebookOptions,处理器类：FacebookHandler
public static class FacebookAuthenticationOptionsExtensions { public static AuthenticationBuilder AddFacebook(this AuthenticationBuilder builder) =&gt; builder.AddFacebook(FacebookDefaults.AuthenticationScheme, _ =&gt; { }); public static AuthenticationBuilder AddFacebook(this AuthenticationBuilder builder, Action&lt;FacebookOptions&gt; configureOptions) =&gt; builder.AddFacebook(FacebookDefaults.AuthenticationScheme, configureOptions); public static AuthenticationBuilder AddFacebook(this AuthenticationBuilder builder, string authenticationScheme, Action&lt;FacebookOptions&gt; configureOptions) =&gt; builder.AddFacebook(authenticationScheme, FacebookDefaults.
  
  
  <div class="read-more-link">
    <a href="/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_7_authentication_%E5%85%B6%E4%BB%96/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_6_authentication_openidconnect/">AspNetCore3.1_Secutiry源码解析_6_Authentication_OpenIdConnect</a>
  </h1>
  <time datetime="2020-03-25T21:33:12&#43;0800" class="post-date">Wed, Mar 25, 2020</time>
  系列文章目录  AspNetCore3.1_Secutiry源码解析_1_目录 AspNetCore3.1_Secutiry源码解析_2_Authentication_核心流程 AspNetCore3.1_Secutiry源码解析_3_Authentication_Cookies AspNetCore3.1_Secutiry源码解析_4_Authentication_JwtBear AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth AspNetCore3.1_Secutiry源码解析_6_Authentication_OpenIdConnect AspNetCore3.1_Secutiry源码解析_7_Authentication_其他 AspNetCore3.1_Secutiry源码解析_8_Authorization_核心项目 AspNetCore3.1_Secutiry源码解析_9_Authorization_Policy  oidc简介 oidc是基于oauth2.0的上层协议。
OAuth有点像卖电影票的，只关心用户能不能进电影院，不关心用户是谁。而oidc则像身份证，扫描就可以上飞机，一次扫描，机场不仅能知道你是否能上飞机，还可以知道你的身份信息。
oidc兼容OAuth2.0, 可以实现跨顶级域的SSO(单点登录、登出)，下个系列要学习的IdentityServer4就是对oidc协议族的一个具体实现框架。
更多理论知识看下面的参考资料，本系列主要过下源码脉络
博客园
 https://www.cnblogs.com/linianhui/p/openid-connect-core.html
 协议
 https://openid.net/connect/
 依赖注入 默认架构名称是OpenIdConnect，处理器类是OpenIdConnectHandler，配置类是OpenIdConnectOptions
public static AuthenticationBuilder AddOpenIdConnect(this AuthenticationBuilder builder) =&gt; builder.AddOpenIdConnect(OpenIdConnectDefaults.AuthenticationScheme, _ =&gt; { }); public static AuthenticationBuilder AddOpenIdConnect(this AuthenticationBuilder builder, Action&lt;OpenIdConnectOptions&gt; configureOptions) =&gt; builder.AddOpenIdConnect(OpenIdConnectDefaults.AuthenticationScheme, configureOptions); public static AuthenticationBuilder AddOpenIdConnect(this AuthenticationBuilder builder, string authenticationScheme, Action&lt;OpenIdConnectOptions&gt; configureOptions) =&gt; builder.AddOpenIdConnect(authenticationScheme, OpenIdConnectDefaults.DisplayName, configureOptions); public static AuthenticationBuilder AddOpenIdConnect(this AuthenticationBuilder builder, string authenticationScheme, string displayName, Action&lt;OpenIdConnectOptions&gt; configureOptions) { builder.
  
  
  <div class="read-more-link">
    <a href="/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_6_authentication_openidconnect/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_5_authentication_oauth/">AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth</a>
  </h1>
  <time datetime="2020-03-24T23:27:45&#43;0800" class="post-date">Tue, Mar 24, 2020</time>
  系列文章目录  AspNetCore3.1_Secutiry源码解析_1_目录 AspNetCore3.1_Secutiry源码解析_2_Authentication_核心流程 AspNetCore3.1_Secutiry源码解析_3_Authentication_Cookies AspNetCore3.1_Secutiry源码解析_4_Authentication_JwtBear AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth AspNetCore3.1_Secutiry源码解析_6_Authentication_OpenIdConnect AspNetCore3.1_Secutiry源码解析_7_Authentication_其他 AspNetCore3.1_Secutiry源码解析_8_Authorization_核心项目 AspNetCore3.1_Secutiry源码解析_9_Authorization_Policy  系列文章目录  AspNetCore3.1_Secutiry源码解析_1_目录 AspNetCore3.1_Secutiry源码解析_2_Authentication_核心流程 AspNetCore3.1_Secutiry源码解析_3_Authentication_Cookies AspNetCore3.1_Secutiry源码解析_4_Authentication_JwtBear AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth AspNetCore3.1_Secutiry源码解析_6_Authentication_OpenIdConnect AspNetCore3.1_Secutiry源码解析_7_Authentication_其他 AspNetCore3.1_Secutiry源码解析_8_Authorization_核心项目 AspNetCore3.1_Secutiry源码解析_9_Authorization_Policy  OAuth简介 现在随便一个网站，不用注册，只用微信扫一扫，然后就可以自动登录，然后第三方网站右上角还出现了你的微信头像和昵称，怎么做到的？
sequenceDiagram 用户-x站点: 请求微信登录 x站点-微信: 请求 oauth token 微信-用户: x站点请求基本资料权限,是否同意? 用户-微信: 同意 微信-x站点: token x站点-微信: 请求user基本资料(token) 微信-微信: 校验token 微信-x站点: user基本资料   大概就这么个意思，OAuth可以让第三方获取有限的授权去获取资源。
入门的看博客
 https://www.cnblogs.com/linianhui/p/oauth2-authorization.html
 英文好有基础的直接看协议
 https://tools.ietf.org/html/rfc6749
 依赖注入 配置类：OAuthOptions
处理器类： OAuthHandler
public static class OAuthExtensions { public static AuthenticationBuilder AddOAuth(this AuthenticationBuilder builder, string authenticationScheme, Action&lt;OAuthOptions&gt; configureOptions) =&gt; builder.
  
  
  <div class="read-more-link">
    <a href="/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_5_authentication_oauth/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_4_authentication_jwtbear/">AspNetCore3.1_Secutiry源码解析_4_Authentication_JwtBear</a>
  </h1>
  <time datetime="2020-03-22T16:29:29&#43;0800" class="post-date">Sun, Mar 22, 2020</time>
  系列文章目录  AspNetCore3.1_Secutiry源码解析_1_目录 AspNetCore3.1_Secutiry源码解析_2_Authentication_核心流程 AspNetCore3.1_Secutiry源码解析_3_Authentication_Cookies AspNetCore3.1_Secutiry源码解析_4_Authentication_JwtBear AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth AspNetCore3.1_Secutiry源码解析_6_Authentication_OpenIdConnect AspNetCore3.1_Secutiry源码解析_7_Authentication_其他 AspNetCore3.1_Secutiry源码解析_8_Authorization_核心项目 AspNetCore3.1_Secutiry源码解析_9_Authorization_Policy  JwtBear简介 首先回想一下Cookie认证，Cookie认证在用户登录成功之后将用户信息加密后写入浏览器Cookie中，服务端通过解析Cookie内容来验证用户登录状态。这样做有几个缺陷：
 Cookie加密方式是微软自己定义的，并非国际标准，其他语言无法识别。 依赖Cookie，在跨域场景下，存在诸多限制。  CORS除非设置白名单否则是不允许带Cookie的； 大部分浏览器对跨域设置Cookie有严格的限制。比如：A网站使用iframe嵌套B网站来实现集成，B网站依赖Cookie来维持登录态，如果是Chrome浏览器，需要将Cookie的Secure设置为true，即必须使用https，同时将SameSite设置为None，这样可以解决问题但是存在跨站访问攻击（CSRF）的安全漏洞，而Safari则是完全禁止设置跨站Cookie的）    JwtBear可以解决上面的缺点
 Jwt是国际标准 Jwt不依赖Cookie，不存在跨站访问攻击问题  依赖注入 提供了四个重载方法，主要设置配置类 JwtBearerOptions。 默认添加名称为Bearer的认证Schema，JwtBearerHandler为处理器类。
public static class JwtBearerExtensions { public static AuthenticationBuilder AddJwtBearer(this AuthenticationBuilder builder) =&gt; builder.AddJwtBearer(JwtBearerDefaults.AuthenticationScheme, _ =&gt; { }); public static AuthenticationBuilder AddJwtBearer(this AuthenticationBuilder builder, Action&lt;JwtBearerOptions&gt; configureOptions) =&gt; builder.AddJwtBearer(JwtBearerDefaults.AuthenticationScheme, configureOptions); public static AuthenticationBuilder AddJwtBearer(this AuthenticationBuilder builder, string authenticationScheme, Action&lt;JwtBearerOptions&gt; configureOptions) =&gt; builder.
  
  
  <div class="read-more-link">
    <a href="/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_4_authentication_jwtbear/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_3_authentication_cookies/">AspNetCore3.1_Secutiry源码解析_3_Authentication_Cookies</a>
  </h1>
  <time datetime="2020-03-19T22:52:39&#43;0800" class="post-date">Thu, Mar 19, 2020</time>
  系列文章目录  AspNetCore3.1_Secutiry源码解析_1_目录 AspNetCore3.1_Secutiry源码解析_2_Authentication_核心流程 AspNetCore3.1_Secutiry源码解析_3_Authentication_Cookies AspNetCore3.1_Secutiry源码解析_4_Authentication_JwtBear AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth AspNetCore3.1_Secutiry源码解析_6_Authentication_OpenIdConnect AspNetCore3.1_Secutiry源码解析_7_Authentication_其他 AspNetCore3.1_Secutiry源码解析_8_Authorization_核心项目 AspNetCore3.1_Secutiry源码解析_9_Authorization_Policy  依赖注入 AuthenticationBuilder AddCookie(this AuthenticationBuilder builder); AuthenticationBuilder AddCookie(this AuthenticationBuilder builder, string authenticationScheme); AuthenticationBuilder AddCookie(this AuthenticationBuilder builder, Action&lt;CookieAuthenticationOptions&gt; configureOptions); 提供了几个重载方法，可以使用默认配置，或者通过委托修改配置类CookieAuthenticationOptions的值。
可以定义登录、登出、拒绝登录页面地址、Cookie过期时间、生命周期各阶段事件等。
classDiagram class CookieAuthenticationOptions{ CookieBuilder Cookie IDataProtectionProvider DataProtectionProvider bool SlidingExpiration PathString LoginPath PathString LogoutPath PathString AccessDeniedPath CookieAuthenticationEvents Events ISecureDataFormat TicketDataFormat ITicketStore SessionStore TimeSpan ExpireTimeSpan } class AuthenticationSchemeOptions{ string ClaimsIssuer object Events Type EventsType string ForwardDefault string ForwardAuthenticate string ForwardChallenge string ForwardForbid string ForwardSignIn string ForwardSignOut Func ForwardDefaultSelector } CookieAuthenticationOptions--AuthenticationSchemeOptions   如果没有定义配置，则会使用CookieAuthenticationDefaults定义的默认配置
  
  
  <div class="read-more-link">
    <a href="/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_3_authentication_cookies/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_2_authentication_%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/">AspNetCore3.1_Secutiry源码解析_2_Authentication_核心流程</a>
  </h1>
  <time datetime="2020-03-18T21:19:15&#43;0800" class="post-date">Wed, Mar 18, 2020</time>
  系列文章目录  AspNetCore3.1_Secutiry源码解析_1_目录 AspNetCore3.1_Secutiry源码解析_2_Authentication_核心流程 AspNetCore3.1_Secutiry源码解析_3_Authentication_Cookies AspNetCore3.1_Secutiry源码解析_4_Authentication_JwtBear AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth AspNetCore3.1_Secutiry源码解析_6_Authentication_OpenIdConnect AspNetCore3.1_Secutiry源码解析_7_Authentication_其他 AspNetCore3.1_Secutiry源码解析_8_Authorization_核心项目 AspNetCore3.1_Secutiry源码解析_9_Authorization_Policy  依赖注入 框架提供了三个依赖注入重载方法。
//注入认证服务 services.AddAuthentication(); //注入认证服务并制定默认架构名 services.AddAuthentication(&#34;Cookies&#34;); //注入认证服务并设置配置项 services.AddAuthentication(config =&gt; { }); 看看注入代码
public static AuthenticationBuilder AddAuthentication(this IServiceCollection services) { if (services == null) { throw new ArgumentNullException(nameof(services)); } services.AddAuthenticationCore(); services.AddDataProtection(); services.AddWebEncoders(); services.TryAddSingleton&lt;ISystemClock, SystemClock&gt;(); return new AuthenticationBuilder(services); } AddAuthenticationCore注入了认证服务的核心对象。这个方法在Authentication.Core项目，这个项目定义了认证服务的核心对象，在Authentication.Abstractions项目中定义了核心接口。
AddAuthenticationCore方法注入了IAuthenticationService，IClaimsTransformation，IAuthenticationHandlerProvider，IAuthenticationSchemeProvider
public static IServiceCollection AddAuthenticationCore(this IServiceCollection services) { if (services == null) { throw new ArgumentNullException(nameof(services)); } services.TryAddScoped&lt;IAuthenticationService, AuthenticationService&gt;(); services.TryAddSingleton&lt;IClaimsTransformation, NoopClaimsTransformation&gt;(); // Can be replaced with scoped ones that use DbContext  services.
  
  
  <div class="read-more-link">
    <a href="/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_2_authentication_%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_secutiry%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_1_%E7%9B%AE%E5%BD%95/">AspNetCore3.1_Secutiry源码解析_1_目录</a>
  </h1>
  <time datetime="2020-03-17T23:01:38&#43;0800" class="post-date">Tue, Mar 17, 2020</time>
  系列文章目录  AspNetCore3.1_Secutiry源码解析_1_目录 AspNetCore3.1_Secutiry源码解析_2_Authentication_核心流程 AspNetCore3.1_Secutiry源码解析_3_Authentication_Cookies AspNetCore3.1_Secutiry源码解析_4_Authentication_JwtBear AspNetCore3.1_Secutiry源码解析_5_Authentication_OAuth AspNetCore3.1_Secutiry源码解析_6_Authentication_OpenIdConnect AspNetCore3.1_Secutiry源码解析_7_Authentication_其他 AspNetCore3.1_Secutiry源码解析_8_Authorization_核心项目 AspNetCore3.1_Secutiry源码解析_9_Authorization_Policy  概述 最近一直在学习研究认证授权这一块，从AspNetCore的Security解决方案，到Identity，再到OAuth2.0、OpenIdConnect协议，然后IdentityServer4，这一块的东西十分多而且复杂，可以算是DotNet里最难啃的骨头之一了。计划做个认证授权的系列，藉由分析源码来学习、记录和加深对这一块的理解。
如图是AspNetCore.Security解决方案的项目结构。
可以看到主要有5个解决方案文件夹
 Authentication：认证 Authorization：授权 CookiePolicy：Cookie策略中间件 _dependencies：依赖项目 benchmarks：测试项目  最主要的是Authentication和Authorization这两个里面的内容。
什么是Authentication， 什么是Authorization 初次接触这一块，可能会比较懵，啥玩意儿啊，俩单词长得差不多像念绕口令的。
我尝试大白话解释下。
Authentication（认证）：who are you。系统获知当前用户身份的过程就叫认证。可以类比成身份证。通常来说，在你登录的时候，系统就知道了你的身份，然后将当前用户信息加密后存储在Cookie中来维持登录态。
Authorization（授权）：are you allowed。授权就是判断你有没有权限，比如网管拿着你身份证一看，你这不行，未满十八岁，不能在我这上网。而有的黑网吧是没有这个要求的，给钱就能玩。正经网吧和黑网吧，这就是需要授权资源和匿名资源的区别。
Authentication项目简介 我们可以看到第三个文件夹叫Core，里面只有一个项目叫Microsoft.AspNetCore.Authentication，是我们使用DotNet授权框架必须引用的一个核心类库。
然后其他的Certificate、Cookies、OAuth、OpenIdConnect等这些，在DotNet里叫做Schema，可以翻译为架构。这就好比，证明身份的方式有很多种，身份证、护照、户口本都可以，同理网络世界也有各种各样的协议。最常见传统的是方式是使用Cookie，也可以使用无状态的JwtBear，现在常见的微信、QQ等扫码登录是使用的OAuth协议。
Authorization项目简介 授权就两个项目，[Microsoft.AspNetCore.Authorization.Policy],[Microsoft.AspNetCore.Authorization]。多看看源码的话，应该对Policy这个词很熟悉了，在DotNet里面属于高频词汇，意思是策略。这两个项目允许设置不同的授权策略/规则，来实现高度灵活的授权方案。
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_middleware%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_4_staticfiles/">AspNetCore3.1_Middleware源码解析_4_StaticFiles</a>
  </h1>
  <time datetime="2020-03-16T21:59:17&#43;0800" class="post-date">Mon, Mar 16, 2020</time>
  概述 AspNetCore提供了StaticFiles中间件，使我们可以轻松访问静态文件。
使用方法 AspNetCore提供了三个重载方法，没有特殊需求的情况下，我们使用无参的就可以了。
//使用默认配置 app.UseStaticFiles(); //自定义静态资源相对路径 app.UseStaticFiles(&#34;/MyCustomStaticFilePath&#34;); //所有可以配置的选项 app.UseStaticFiles(new StaticFileOptions { //用于映射file的content-type  ContentTypeProvider = null, //ContentTypeProvider无法决定content-type时的默认content-type  DefaultContentType = null, //文件提供程序  FileProvider = new PhysicalFileProvider(&#34;/&#34;), //Https请求，ResponseCompression中间件启用的情况下，是否对返回值压缩  HttpsCompression = Microsoft.AspNetCore.Http.Features.HttpsCompressionMode.Compress, //委托，状态码和Headers设置完，Body写入前触发，可用于修改响应头  OnPrepareResponse = null, //映射静态资源的相对路径  RequestPath = &#34;/MyStaticFiles&#34;, //是否伺服未知文件类型  ServeUnknownFileTypes = false }); TO BE CONTINUE&hellip;
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_middleware%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_3_httpsredirection/">AspNetCore3.1_Middleware源码解析_3_HttpsRedirection</a>
  </h1>
  <time datetime="2020-03-16T18:20:41&#43;0800" class="post-date">Mon, Mar 16, 2020</time>
  概述 上文提到3.1版本默认没有使用Hsts，但是使用了HttpsRedirection这个中间件。看名字就很好理解，https跳转，顾名思义，就是跳转到https地址。
使用场景：当用户使用http访问网站时，自动跳转到https地址。这样更加安全，也更加方便，因为不需要用户特意输入https://。
具体怎么实现的我们来看看。
app.UseHttpsRedirection(); 使用方法 跟Hsts一样，HttpsRedirection默认是不需要注入的，除非你需要修改默认配置。
services.AddHttpsRedirection(config =&gt; { //https地址的端口号，默认null  config.HttpsPort = 12345; //跳转响应的状态码，默认307  config.RedirectStatusCode = 302; }); 直接使用中间件即可
app.UseHttpsRedirection(); 源码解析 源代码很简单，只有两个类：HttpsRedirectionOptions配置类，HttpsRedirectionMiddleware中间件
HttpsRedirectionOptions就只有两个配置项
/// &lt;summary&gt;  /// Options for the HttpsRedirection middleware  /// &lt;/summary&gt;  public class HttpsRedirectionOptions { /// &lt;summary&gt;  /// The status code used for the redirect response. The default is 307.  /// &lt;/summary&gt;  public int RedirectStatusCode { get; set; } = StatusCodes.
  
  
  <div class="read-more-link">
    <a href="/aspnetcore3.1_middleware%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_3_httpsredirection/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_middleware%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_2_hsts/">AspNetCore3.1_Middleware源码解析_2_Hsts</a>
  </h1>
  <time datetime="2020-03-16T12:40:46&#43;0800" class="post-date">Mon, Mar 16, 2020</time>
  概述 在DotNetCore2.2版本中，当你新增一个WebAPI项目，Startup.cs文件中，会有这么一行代码（3.1版本默认没有使用该中间件）。
if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } else { // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.  app.UseHsts(); } 这段代码，翻译一下就是开发环境使用开发异常页面，其他环境使用Hsts中间件。这个Hsts中间件是个什么东西呢，今天来看一看。
HSTS是什么 HTTP严格传输安全协议（英语：HTTP Strict Transport Security，简称：HSTS）。
简单描述一下协议内容，就是出于安全考虑，强制客户端使用https与服务端连接。
为什么要这么做呢，比较学术和系统的论述自行查看下面的链接。我这里举个通俗的栗子。
首先我们知道http是不安全的，而https是安全的，它能保障你访问的A网站就是A，而不是什么其他的野鸡。
某一天，你去逛淘宝，你往chrome地址栏敲 taobao.com，正常情况下岁月安好，什么问题都没有。假如，这时候你接入的是公共免费wifi，而这背后有人搞鬼，或者说你的电脑已经中了病毒，它可以将你跳转到一个跟taobao一模一样的网站 (怎么做到的？比如修改你的host文件，将taobao域名指向他自己搭建的假taobao网站ip)，浏览器并不知道taobao需要使用https访问，所以无法保护你，你的钱就在你的鼠标点击下，跟随着一个个http请求流入到了黑客的账户。
那要怎么办呢，不上公共wifi行不行，行，但是防不胜防，不是根本的办法。 那我们告诉浏览器taobao需要用https访问行不行，听起来不错，那怎么告诉呢，我们来搞个协议，这个协议就是HSTS。
一句话描述HTST：当你首次使用https访问了taobao成功后，taobao会返回Strict-Transport-Security头，表明我这个网站需要使用https访问，浏览器记录下这个信息，以后taobao的请求都会使用https，因此堵住了上面案例的安全漏洞。
 https://baike.baidu.com/item/HTTP%E4%B8%A5%E6%A0%BC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE/16018283?fromtitle=HSTS&amp;fromid=8665782&amp;fr=aladdin
  https://developer.mozilla.org/zh-CN/docs/Security/HTTP_Strict_Transport_Security
  https://tools.ietf.org/html/rfc6797
 HSTS中间件的使用 通常，我们不需要写Hsts的注入代码，因为它没有任何需要注入的服务。除非你需要修改它的默认配置。
services.AddHsts(config =&gt; { //是否包含子域名，默认false  config.IncludeSubDomains = true; //有效时长，默认30天  config.MaxAge = TimeSpan.FromDays(365); }); 然后，使用中间件即可。
  
  
  <div class="read-more-link">
    <a href="/aspnetcore3.1_middleware%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_2_hsts/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/aspnetcore3.1_middleware%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_1_cors/">AspNetCore3.1_Middleware源码解析_1_CORS</a>
  </h1>
  <time datetime="2020-03-15T17:26:10&#43;0800" class="post-date">Sun, Mar 15, 2020</time>
  概述 什么是跨域 在前后端分离开发方式中，跨域是我们经常会遇到的问题。所谓的跨域，就是出于安全考虑，A域名向B域名发出Ajax请求，浏览器会拒绝，抛出类似下图的错误。
JSONP JSONP不是标准跨域协议，更像是聪明程序员投机取巧的办法。这种方式的原理就是js是没有跨域限制的，你想想你引用bootstrap.js是不是网络地址放进来就可以用了。
实际上，所有src属性都不限制跨域的，比如img标签使用跨域图片是不会有问题的。
过程大体分下面四步。
 首先约定数据格式和回调函数名 A网站引用B网站的js B网站用约定好的回调函数将数据包裹起来，在A引用的js里返回 A网站在回调函数中获取数据  这个方案的优点是兼容性比较好，古老版本的IE都可以支持，毕竟只是基于js的一个技巧，并没有新的技术或协议。
缺点比较明显，只支持GET，理解起来比较别扭，调用失败不会返回http状态码，安全性存在一定问题。
CORS CORS的全称是Cross Origin Resource Sharing，翻译过来就是跨域资源共享。
跨域问题本质就是浏览器处于安全考虑，阻止了客户端跨域请求。但说到底，客户端请求安不安全还不是服务端说了算的，服务端都说我们家大米你们随便吃，浏览器还阻止，这不是碍事吗，你个物业还当自己业主啦？
但是浏览器也不能随便放行，毕竟网上冲浪的不仅有正经客人，还有小偷，真出问题了还得吐槽物业稀烂。浏览器说，服务端，这个客户端要去你家吃大米，你得告诉我你同不同意啊，服务端说我咋告诉你啊，我总不能来个人就冲着岗亭喊 I&rsquo;M OK吧。浏览器说那我们搞个协议吧，整个互联网小区都按这个规范来，你们就按这个格式回复我。
这个协议就是CORS了。
下图描述了简单请求的流程。
graph LR; A(客户端)--B(不带Orgin跨域请求); B--C(浏览器拒绝); A--D(带Origin跨域请求); D--E(服务端返回白名单); E--F(白名单内); E--G(白名单外); F--H(浏览器放行); G--C    关于CORS简单请求，复杂请求，以及详细内容参考下面文章，不再赘述。 http://www.ruanyifeng.com/blog/2016/04/cors.html
 CORS的缺点就是IE10以下不支持，如果你的项目需要兼容这些浏览器的话需要注意。
怎么实现CORS CORS说白了其实就是在响应头里加东西，你可以在运维环节比如nginx加，可以在代码里加，常见的做法是中间件统一处理。AspNetCore为我们提供了CORS中间件。
AspNetCore_CORS中间件的使用 使用CORS中间件两句代码就够了,在Startup文件中
//注入CORS相关的服务，配置跨域策略 public void ConfigureServices(IServiceCollection services) { //策略1，允许所有域名跨域访问  config.AddPolicy(&#34;policy1&#34;, policy =&gt; { policy.AllowAnyOrigin(). AllowAnyMethod(). AllowAnyOrigin(). AllowAnyMethod(); //注意：AllowAnyOrigin和AllowCredential不能同时出现，否则会报错  //AllowCredential即是否允许客户端发送cookie，基于安全原因，CORS协议规定不允许AllowOrigin为通配符的情况下设置允许发送cookie  //.AllowCredentials();  }); //策略2，仅允许特定域名、方法、请求头访问  config.
  
  
  <div class="read-more-link">
    <a href="/aspnetcore3.1_middleware%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90_1_cors/">Read More…</a>
  </div>
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_2_%E4%BD%BF%E7%94%A8webhook%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/">构建个人博客-2-使用Webhook自动发布</a>
  </h1>
  <time datetime="2020-03-14T21:15:28&#43;0800" class="post-date">Sat, Mar 14, 2020</time>
  概述 上篇介绍了怎么利用hugo搭建个人博客。 有一个地方还是有点不方便，就是git push之后需要等半个小时才能发布。
所以我想利用github的webhook实现每次推送自动发布。
github设置钩子 所谓的webhook,就是钩子,就是github搞事情的时候就会通知你。所以你需要准备一个接口接收github的post请求。 这里我设置为接收json格式数据，仅push时通知。 编写接口 生产环境一般是使用Travis Ci或者Jenkins来实现类似功能，但这对于我来说有点重型了。所以自己写个接口简单实现下。 需求很简单，每当有代码推送的时候，拉取git并发布到blog部署目录。
我这里使用.net core实现，代码十分简单，其实就一行，执行blog.sh脚本。
再看下这个blog.sh脚本的内容，也很简单，首先拉取git内容，再拷贝到部署目录就行了。
#!/bin/bash cd /git/blog git pull cp -rf /git/blog/public/. /www/wwwroot/www.holdengong.com/ 这里有3个小坑要注意
 第一行的 #!/bin/bash 是必须的 脚本必须是ANSI编码 需要执行命令 chmod +x blog.sh 是脚本可执行  完成 大功告成。接下来可以愉快的写日志了，写完只需要签入，自动发布，爽！
 这篇博客由系统自动发布
 
  
</article><article class="post">
  <h1 class="post-title">
    <a href="https://holdengong.com/%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_1_%E4%BD%BF%E7%94%A8hugo%E5%BF%AB%E9%80%9F%E6%88%90%E5%9E%8B/">构建个人博客_1_使用Hugo快速成型</a>
  </h1>
  <time datetime="2020-03-14T14:42:38&#43;0800" class="post-date">Sat, Mar 14, 2020</time>
  概述 人在武汉，病毒肆虐。
隔离久了，有点闷，闲余时间找点事情做。
建个博客吧， 内容不重要，写不写也不那么要紧，目前水平也写不出什么有深度的东西。
但是这个姿势一定要优美， 过程一定要折腾。
OK, 开干。
下载Hugo  https://github.com/gohugoio/hugo/releases
 笔者是Windows系统，下载hugo_0.67.0_Windows-64bit.zip，解压到本地后，将路径加入到环境变量。
创建站点 首先创建一个git仓库
拉取到本地
如文件夹名为blog
cd blog hugo new site . 编写正文 hugo new hello-world.md 下载主题 cd theme git clone https://github.com/spf13/hyde.git 调试 hugo server --theme=hyde --buildDrafts 然后浏览器打开 http://localhost1313 可以查看效果
发布 发布前将hello-world.md的draft字段修改为true, https://holdengong.com/ 为你网站的域名
hugo --theme=hyde -b https://holdengong.com/ 执行完后会发现生成了public文件夹及内容
部署 云服务器可以使用腾讯云的学生版  https://cloud.tencent.com/act/campus?fromSource=gwzcw.2432501.2432501.2432501&amp;utm_medium=cpc&amp;utm_id=gwzcw.2432501.2432501.2432501
 安装宝塔面板linux管理工具  https://www.bt.cn/
 安装git yum -y install git 拉取git仓库, e.g.仓库目录为/git/blog
宝塔新建站点 e.g.站点根路由为/www/wwwroot/www.holdengong.com
定时发布 利用linux的定时任务做一个简单的定时发布
  
  
  <div class="read-more-link">
    <a href="/%E6%9E%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2_1_%E4%BD%BF%E7%94%A8hugo%E5%BF%AB%E9%80%9F%E6%88%90%E5%9E%8B/">Read More…</a>
  </div>
  
</article>
</div>
    </main>

    
      
    
  </body>
</html>
